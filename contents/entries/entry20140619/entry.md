#### KenOKABE tech blog
####[←ブログコンテンツ](http://kenokabe.github.io/contents/entries/entry0/entry.html)

#記事シリーズ
### [Swiftで脱アルゴリズム！iOS開発を関数型（宣言型）プログラミングへパラダイムシフトしてみる【脱アルゴリズム宣言①】](http://qiita.com/kenokabe/items/41189c45001321c9e283)
###  [関数リアクティブプログラミング（FRP）で分断された2つの世界を繋ぐ【脱アルゴリズム宣言②】](http://qiita.com/kenokabe/items/a8477694a499ca869cde)
### [関数型（宣言型）プログラミングで無限をコーディングする「遅延評価」のわかりやすい解説【脱アルゴリズム宣言③】](http://qiita.com/kenokabe/items/821ce4020644372b648c)

# 関数型（宣言型）プログラミングで無限をコーディングする「遅延評価」のわかりやすい解説【脱アルゴリズム宣言③】
一応、成り行き上Swiftのタグをつけていますが、実質JavaScript/node.jsの記事になっています。

理由は、ObjectiveCに比べて随分と扱いやすくなったけれど、自分自身まだ慣れていないということ。

もうひとつ重要なのは、Swiftは関数型プログラミング言語であり、より広義の宣言型パラダイムを積極的に導入することが可能、ここは押さえておきたいのだが、この記事で解説するような宣言型でコーディングするデモンストレーションするに十分な道具立てが出揃っていない、ことが理由になります。

前回の記事、

[関数リアクティブプログラミング（FRP）で分断された2つの世界を繋ぐ【脱アルゴリズム宣言②】](http://qiita.com/kenokabe/items/a8477694a499ca869cde)

では、 **関数リアクティブプログラミング（FRP）**の導入をしました。

FRPは実務に耐えうる宣言型パラダイムにおけるプログラミングを実現する上で、必須の道具立てだと言えます。JavaScriptその他の世界で活発に導入が進んでいる一方でSwiftはこれから、だと思います。そしてSwiftは言語仕様として「モダン」な関数型言語であるので、非常に類似した関数型言語であるJavaScriptで成功した道具立ては即座にSwiftの世界にも反映されていくだろうから、道具立てが出揃うに従って、近い将来まったく同じ事が実現できるはずです。

さて、今回は、FRP同様に、宣言型パラダイムの道具立てとして必須である **遅延評価**について解説します。

同時に、前回導入した **FRP**と、今回導入する **遅延評価**は数学的構造として本質的に等価であることも証明します。

FRPと遅延評価が本質的に同じものだ、という解説はあまり見かけませんが（どこにもそういうことが書かれていないので自分でこれを理解するまでに時間がかかりました）、この記事を読み進めるに従ってなるほどと納得できるように解説したつもりです。

読者の新たな地平が開けることを願います。

##「アルゴリズム」というバズワード、言葉の定義について
さて「本質」の話ですが、本論に進める前に、「言葉の問題」を片付けてしまわねばなりません。

このシリーズでは **宣言型パラダイム**を実用的プログラミングに導入することを目指して、相反するプログラミングパラダイムである **命令型**からの脱却を強く意識し、そのアイコンとして **「脱アルゴリズム」**というプロパガンダを掲げています。

「脱アルゴリズム」というネーミングは狙い通り大変キャッチーで、別の言い方をすれば「コントラバーシャル」なので、巷で随分と話題になっていた（バズられていた）ようです。

ネットには毎日誰かに「ツッコミ」を入れると称して「情弱」だの馬鹿にして人を貶める事を生きがいにしているような「俺はなんでも知っている、何でもお見通し」系の疾患を抱えるアレな人たちがいますが、何の事はないただの「あら探し」「揚げ足取り」に終始しているに過ぎません。

自分が目にした「一番アレなツッコミ」とは、
>誰か……「脱アルゴリズム！」って言ってる人に「あなたのやってるそれを『アルゴリズム』と呼ぶのですよ」って優しく教えてあげて……」

でした。まあ「アレ」ですよね。そんなに賢くて、何度も知っている、何でもお見通しならば、ここに書いていることも最初から全部知っており理解もしているのだろうし、さぞかし秀逸なプログラムを書けるのでしょうね。すごいですよね。

さて、アレな連中が「揚げ足取り」をしているのは、ただひとつに集約されます。

####「アルゴリズム」という言葉の定義です。

この記事のシリーズでは、今更言うまでもなく **パラダイム**つまり思考の枠組の話をしています。プログラミングの土台となる世界観を示し、アプローチの仕方を論じ、指向性を定義します。

**オブジェクト指向**というのも、ひとつのパラダイムでありアプローチであり指向性です。これは、どういうのが厳密なオブジェクトなのかを論じるのではなく、あくまでも方法論の話です。

命令型パラダイムVS宣言型パラダイムにおいて、何が厳密な「アルゴリズム」なのか？という言葉の定義の話など本質じゃないですよね。

とはいえ、きちんと確認しておきましょう。

####「アルゴリズム」という言葉の定義は何でしょうか？

[Algorithm](http://en.wikipedia.org/wiki/Algorithm)によれば、

1.Word origin
2.Informal definition
3.Formalization

と目次が並びます。

「語源」があり「インフォーマルな定義」があり「定式化」がある、つまり単なる[バズワード](http://ja.wikipedia.org/wiki/%E3%83%90%E3%82%BA%E3%83%AF%E3%83%BC%E3%83%89)だということがわかります。


Formalization「定式化」によると
>Typically, when an algorithm is associated with processing information, data is read from an input source, written to an output device, and/or stored for further processing. Stored data is regarded as part of the internal state of the entity performing the algorithm. In practice, the state is stored in one or more data structures.

「典型的には」から始まり、
>Stored data is regarded as part of the internal state of the entity performing the algorithm

"internal state"つまり「内部状態」という命令型の典型要素が書かれている。

関数型パラダイムでは極力、内部状態の保持を排除するのは最初の記事で説明したとおりです。

>For some such computational process, the algorithm must be rigorously defined: specified in the way it applies in all possible circumstances that could arise. That is, any conditional steps must be systematically dealt with, case-by-case; the criteria for each case must be clear (and computable).

>Because an algorithm is a precise list of precise steps, the order of computation is always critical to the functioning of the algorithm. Instructions are usually assumed to be listed explicitly, and are described as starting "from the top" and going "down to the bottom", an idea that is described more formally by flow of control.

>アルゴリズムは、明確なステップの明確なリストなので、アルゴリズムの実行順序は常にクリティカルである

この「実行順序」というのはズバリ「命令型」パラダイムの話題です。

「宣言型」では実行順序は関係ありません。純粋関数型言語、遅延評価型言語（今回説明するやつです）であるHaskellではコードの順番は関係なくフラットに定義することが可能です。つまり、このアルゴリズムの定式化の説明とは矛盾する。

>"Instructions"つまり「命令」はトップからボトムに記述し「フローのコントロール」を記述する

という説明がなされており、これも命令型の概念説明です。

>So far, this discussion of the formalization of an algorithm has assumed the premises of imperative programming. This is the most common conception, and it attempts to describe a task in discrete, "mechanical" means. Unique to this conception of formalized algorithms is the assignment operation, setting the value of a variable. It derives from the intuition of "memory" as a scratchpad. There is an example below of such an assignment.

>「これまでのところ、この議論は、アルゴリズムの定式化が命令型プログラミングを前提に為されている」「これが最も一般的なコンセンプションで、、、」

と続きます。

>For some alternate conceptions of what constitutes an algorithm see functional programming and logic programming.

>「アルゴリズム」の構成概念の代替については、関数型プログラミング、ロジックプログラミングを参照してください

つまり、

####「アルゴリズム」とは「バズワード」であり、「一般的に命令型プログラミングパラダイムを指し示す」のであり、その他の使用は一般的ではない、ということです。

「それがアルゴリズムだと優しく教えてあげましょう」というのは、「この人にとってのアルゴリズム」「この人が考えるアルゴリズムとはこうあるべきものだと考えるアルゴリズム」を誰か他の人に押し付けて揚げ足取りしているに過ぎません。
　
繰り返しますが、本論において重要なのは、これはバズワードではなく構造として相反する、命令型と宣言型パラダイムの対比作業であり、プログラミングの土台となる世界観を示し、アプローチの仕方を論じ、指向性を定義することです。
　　　　
前回例示したDOMのBOXを移動させるサンプル

http://jsfiddle.net/LLB63/

```
var xyFromEvent = function (v) {
    return {
        x: v.clientX,
        y: v.clientY
    }
}

var getDelta = function (t) {
    var a = t[1];
    var b = t[0];
    return {
        x: a.x - b.x,
        y: a.y - b.y
    };
}

var add = function (p1, p2) {
    return {
        x: p1.x + p2.x,
        y: p1.y + p2.y
    };
}

$().ready(function () {
    var block = $("#clickable-block");
    var html = $("html");

    var startDrag = block.asEventStream('mousedown')
    var endDrag = block.asEventStream('mouseup')

    var draggingDeltas = startDrag.flatMap(function () {
        return html.asEventStream('mousemove')
            .map(xyFromEvent)
            .slidingWindow(2, 2)
            .map(getDelta)
            .takeUntil(endDrag)
    })

    var blockPosition = draggingDeltas.scan({
        x: 0,
        y: 0
    }, add);

    blockPosition.onValue(function (pos) {
        block.css({
            top: pos.y + "px",
            left: pos.x + "px"
        });
    });
});

```

において、

**「命令型パラダイムに纏わる典型的なアルゴリズム」は存在しない、と言い切っても何の問題もない**でしょう。

 また、アルゴリズムとはバズワードですが、如何なるアルゴリズムの定義を採用するとしても、非宣言型アプローチに比べて宣言型アプローチのほうが、言語仕様あるいは外部ライブラリが宣言部分のアルゴリズムを肩代わりして、表層のコードとしてはアルゴリズムはその分だけ隠蔽されるので、ちょうどその分だけアルゴリズムが少なくなっている、というのは歴然とした事実です。

実際に、Objective-CにおいてもFRPを実装することは「ある程度」は可能ですが、Objective-Cは言語仕様として、関数がファーストクラス（第一級）オブジェクトではない、クロージャがない、という関数型プログラミングの土台が欠落しているので、関数プログラミング、FRP土俵として難しい、というのはすでに説明しました。

SwiftやJavaScriptでは言語仕様レベルで、関数型、宣言型パラダイムを導入しやすい、ということです。

##「遅延評価」の説明の前に、そもそも「評価」とは何なのか？復習

**遅延評価**の説明の前に、そもそも **評価** とは何なのか？ここでもう一度復習しておいたほうがよいでしょう。

前回「評価」の説明をしたのは実はこの伏線でもあるのでした。

**評価(Evaluation)**とは、

####数学世界　--コンピューティング（計算）--> 　物理世界

と数学世界の要素を物理世界に展開すること、マッピングすることで、この操作を特に **コンピューティング（計算）**と呼ぶのでした。

##「遅延評価」とは？遅延評価あるいはLazy Evaluation というわかりにくいネーミング

では、

**評価(Evaluation)**が

####数学世界　--コンピューティング（計算）--> 　物理世界

であることを踏まえて、 **遅延評価(Lazy Evaluation)** とは何か？

「評価」が「遅延」される、EvaluationがLazy（怠惰）だ？

まったくイメージがわかないです。というよりこのネーミングは間違ったイメージをもたらし、理解を妨げると思います。

私も当初はこの誤解を招くネーミングで遅延評価が何であるのか、理解するのに随分と苦労させられたと思います。

実は、遅延評価あるいはLazyEvaluationには別の呼び方があって、

**Call By Need**
　 http://ja.wikipedia.org/wiki/%E8%A9%95%E4%BE%A1%E6%88%A6%E7%95%A5#.E5.BF.85.E8.A6.81.E5.91.BC.E3.81.B3

で **必要呼び**とリンク先では訳されています。

こっちのほうが概念的に本質的で正確で簡潔です。

Call By Need = 必要に応じて呼び出される（評価、計算される）ので、 *結果的に* 評価が遅延したり、Lazy怠惰なように見えるのです。。

評価が遅延したり怠惰だと、何か非効率かつ処理速度が落ちるようなイメージがもたらされ、大いなる誤解を招いているのですが、実際のところは、必要な部分だけ呼び出され評価されるので、 **無駄がない、極めて効率的な評価戦略である**と言えます。

遅延評価でGoogle検索してみると、キーワードオプションとして、 **「遅延評価勉強法」**なるものが表示されます。

[勉強が苦手な人向けの「遅延評価勉強法」](http://blog.livedoor.jp/kensuu/archives/50555054.html)というブログ記事群があるようです。

>遅延評価勉強法という言葉があります。これはamachangというjavascrpitを書く人で有名な技術者の方が、ブログで言ってた言葉です。該当するエントリは以下。

[遅延評価的勉強法 - IT戦記 - ](http://d.hatena.ne.jp/amachang/20080204/1202104260)

>これは、おいらが考える「効率のいい勉強法」に近いものがあるので、少しまとめてみました。あくまで主観的に「いい」と思っている勉強法ですが、参考になれば、、

>遅延評価勉強法って？

>まず、以下のサイトがすごくまとまってるので引用してみます。

>「遅延評価」という言葉を調べてみると、「ある式を、その結果が本当に必要になる時点までは評価しないでおくテクニック」とあります。そのメリットは、「条件次第で捨ててしまうような値を事前に準備することは非効率的である。このような場合遅延評価を行うと必要なときだけ値が計算されるので計算量を低減できる」とありました。

>ここから遅延評価勉強法とは、「その知識が必要になった時に初めて勉強する方法」です。もっと言えば、「○○を学んだから××をやってみる」ではなく、「××をやりたいから○○を勉強する」と定義できます。

>ハッカーと遅延評価勉強法(*リンク切れ)

>おいらの言葉で言いなおすと「必要になったら、必要なところだけ勉強する」です。たとえばプログラムを勉強するときに、「書籍を1ページ目からやる」のではなく「2ch型掲示板が作りたいから必要なところを勉強する」のが遅延評価勉強法になります。通常の勉強法と比べて、モチベーションが高く保てます。また、インプットとアウトプットがほぼ同時になされるので理解度、定着率がダントツに違います。

これはまさに効率的勉強法を本能的に生まれながらに習得している頭のいい人達の勉強法だと思います。

勉強法と言うより勉強が好きな人らは概ね先天的に本能的にこうやって勉強している、という感じでしょうか？

「必要になったら、必要なところだけ勉強する」

これはCallByNeedの遅延評価の方法論です。

興味がある一点をとっかかりにして、知的好奇心を満たすがままに、芋づる式にだーっと勉強していくのです。無駄がない、スピードが速い方法です。

必要なただ一点を起点として、さらに必要な部分が増えていく、芋づる式とは別の言葉でいうと、波が広がるような様態で全体にだーっと波及していくのです。

プログラミングの **遅延評価(Lazy Evaluation)** とは、概念的にこれでほぼ完全に説明しつくされていると思います。

>「書籍を1ページ目からやる」のではなく

はい、すでに賢明なる読者はお気づきでしょうが、 **遅延評価(Lazy Evaluation)** 戦略では、コードの1行目から評価(Evaluation)=計算（コンピューティング）することはしません。

コードのある1点にスターティングポイントがあります。そこから、計算に必要な部分だけ芋づる式にコールされて計算されて、それ以外は一切、評価(Evaluation)=計算（コンピューティング）されません。


##評価戦略とは？

さて、ここで **評価戦略** というワードが出てきました。

**遅延評価(Lazy Evaluation)** というのは、あるひとつの **評価戦略** となります。


実は我々が命令型プログラミングのパラダイムでお馴染みで、当たり前のように取り扱うのは **先行評価** です。

これは、謂わば、

>「書籍を1ページ目からやる」

評価戦略です。

####実際のコードで見て行きましょう。

```
var x = 10^10;
var a = 1 + 1;
console.log(a);
```

というJSのコードがあるとします。ChromeなりFirebugなり、ブラウザの開発ツールにでもコピペして実行してみると、

`2`

と表示されるはずです。かんたんですね。

JavaScriptそれからC、Objective-C、それからSwiftも **先行評価**プログラミング言語であるので、コードの先頭から順番に最後の行まで、 *先行する順番どおり* に、計算していきます。

まず1行目の

`var x = 10^10;`

が評価（計算）され、

2行目の

`var a = 1 + 1; //2`

が評価（計算）され、

最後に3行目の

`console.log(a);`

で、まず（）の中の`引数`が評価（計算）されたところ、`a`という変数だったので、すでに評価済みでメモリに格納しているはずの`a`の値である`2`をメモリから引っ張り出してきてきます。

このとき、もし`a`がメモリに格納されていない場合は、

>ReferenceError: a is not defined

とエラーが出るでしょう。

問題がない場合は、()を抱えるconsole.log関数の指令どおり、その引数`a`の参照値である`2`を画面に出力します。

以上が、お馴染みの **先行評価戦略** です。

**先行評価** とは、このように上から下、中から外に順番に評価していく評価戦略です。

しかし、すでにお気づきでしょうが、最初の

`var x = 10^10;`

はどうなったんだ？関係ない、無駄じゃないか？　必要ないのに！

という話になるでしょう。

**先行評価戦略** ではそんなものは一切関知しません。

評価とは最初から最後まで、中から外にくまなく順番に評価していくのであり、必要だろうがそうでなかろうが、関係ない、関知しない、という戦略です。

まあ、無駄ですよね。


一方で、 **遅延評価戦略**ではどうなるのか？

**遅延評価**とは、CallByNeed、必要な一点から、芋づる式に評価していくことでした。

先行評価とは真逆に、遅延評価戦略では、

1. 上から下に順番にくまなく評価していく、ということはしない。
2. 関数（）の中の引数を先に、中から外へ、ではなく、関数の外から（）の中の引数を後に、外から中へ、評価していく。

同じJSのコードですが、

####もしもJSが遅延評価言語であったならば？

という仮定で過程を見て行きましょう。

```
var x = 10^10;
var a = 1 + 1;
console.log(a);
```
まず、コンパイラ（あるいはインタプリタ）は、コードをメモリに読み込んで、 *コードの文字列から論理構造を解釈*しはじめます。

ここまでは先行評価であれなんであれ、どの評価戦略にも共通の必須作業です。

そして　１行目の　`var` という、変数宣言のキーワードを見つける。

実行環境は「ああ宣言してるな」とコードの構造を認識しますが、先行評価戦略のようには計算しない。そのまま捨て置きます。

２行目の　`var` という、変数宣言のキーワードを見つける。

実行環境はまた「ああ宣言してるな」とコードの構造を認識しますが、先行評価戦略のようには計算しない。そのまま捨て置きます。

3行目の　`console.log(a)` を認識します。

とりあえず　() の中身は関係ありません、`console.log` という関数が重要なのです。

もし仮にこの関数が　`doNothing()` という「何もしない関数」であったならば、()の中身が何であれ結局は何もしない関数なのですから（）の中の引数は
**必要ない** ので、評価の対象とはなりません。捨て置かれます。

しかし、

`console.log`

とは、何もしないどころか（）の中身の引数を画面に表示せよ、という関数なので、

「（）の中身の引数を評価することこそが今こそ必要だ！」と実行環境は解釈します。

(）の中身の引数とは、コードによれば`a`と書かれているので、次に、

 「`a`を評価することこそが今こそ必要だ！」と解釈します。

 そこではじめて、必要になった `a` を引っ張りだして評価しようとします。

 引っ張りだすと言っても、とりあえず捨て置かれ、計算もせずにメモリに値は格納されていないので、

 `var a = 1 + 1;`

 という宣言を初めて評価（計算）して、それは`2`である、とメモリに格納します。

 ここで、行き着くところまで行った、これ以上は芋づる式に評価するものはなくなったので、コールされたものがどんどん戻って行き、
 大元の

`console.log`

の指令どおり、めでたく　`2` が画面に出力される、という結果になります。

このように、遅延評価戦略においては、

コードは上から下にくまなく順番に評価されて、関数の中から外にくまなく順番に評価される、ということはありません。

本当に必要な発火点をまず見つけると、そこから外から内へ、コードの順番に関係なく、宣言部分を探しだして必要な順番に評価されていきます。

この場合、コードの１行目にある

`var x = 10^10;`

は、評価（計算）されることはまったくありません。ガン無視です。

結果的というか、必然的に、コード全体の評価に必要がないので評価もされなかった、ということになります。

いやあ遅延評価＝CalByNeedってスバラらしいですね。

そして、賢明なる読者はすでにお気づきでしょうが、遅延評価戦略とは、概念的に宣言型パラダイムです。

コードの実行順序を気にして、上から下にコードが評価される順序を設計してフローチャートを組む、あの「アルゴリズム」の思考法から脱却しています。

アルゴリズムとは、無意識に「先行評価戦略」を大前提として、実行環境とは、コードを上から順番に順序良く読んだまま実行していってくれるもの、という思考に基づく方法論なのです。

遅延評価戦略においては、アルゴリズムから脱却できます。

##先行評価戦略におけるアルゴリズムのしがらみ

論より証拠、先行評価戦略におけるアルゴリズムのしがらみのひとつを例示しましょう。

というより、すでに例示した例のアレです。

###【問題】１から１０までの数字を全部足して表示するコードを書け。（命令形アプローチ）

```
var s = 0;
for(var n=1; n<=10; n++)
  {
    s = s + n;
  }
console.log(s);　//55
```

(javascript)

これは、「命令形プログラミング脳の発想」でもありますが、同時に、命令型パラダイムである「先行評価戦略脳の発想」でもあります。

「宣言型プログラミング脳の発想」「脱アルゴリズム」の手法のひとつとして、

###【問題】１から１０までの数字を全部足して表示するコードを書け。（宣言形アプローチ）


```
var numbers = _([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
var plus = function(a, b)
{
  return (a + b);
};

var result = numbers
             .reduce(plus);

console.log(result);
//55
```
(javascript + 関数型ライブラリ=undersocre/lazy.js)


今回、「脱アルゴリズム宣言」が大いにバズられて、アレな人たちからの愚な揚げ足取りをされる中で、見つけられたアレな発言のひとつが、

「１から１０までの数字を手打ちするのは大変だろう」

みたいな発言でした。

まあ、たしかに、これが「1から10000までの数字」などになると、以上のような手打ちは現実的ではないので、その数字の集合を用意するためには、どっちにせよForループなりを回さないといけない、手法としてはたいして差はない、という考えでしょう。

さて、なぜ「1から10000までの数字」を用意するときに、Forループを回さないといけないのでしょうか？

学校でそう習ったからですか？独学でそれは当たり前のことだと習得したからでしょうか？

何故、そういうのが一般的で当たり前になっているのか？

答えは、これが **命令型**と **先行評価戦略** を大前提としたパラダイムで思考しているからです。

宣言型アプローチ、脱アルゴリズムの発想では、数学の問題は数学の問題そのまま簡潔にコーディングするのが理想というのを考えてきました。

数学において、「1から10000までの数字」を用意するときに、頭のなかで10000回ループを回すでしょうか？

回さないですよね？

じゃあ、なんでコーディングするときには、10000回ループを回すのでしょうか？

何故、10000回ループを回さなければいけないのか？

即ち

「1から10000までの数字」を用意する

という数学上、極めて簡潔で簡単な作業をプログラミングするのに、いったいどういう制限がそこに発生しているのか？

ちょっとここで、問題を簡単にするために、問題を

「0から9999の最初の数字」を用意する

にします。

10000回ループしなければ得られない、ハードルとしては同じですね。

さて、そもそも論として、この問題を数学で取り扱う、数学で当たり前に考えると、 **自然数（この場合０を含むとする）の最初の10000項だ**、と考えるでしょう。

でも、プログラムではその通りに簡潔に表現できないからループを10000回、回すのでしょう？そうですよね？

ここで問題がはっきりしてきます。

**プログラムでは「自然数」っていうのがどうも表現できない。なぜなら「自然数」というのは「無限数列」だから。**

だから有限回ループを回して1ずつ足していくしか方法がない。
　
####数学世界　--コンピューティング（計算）--> 　物理世界

でした。

数学世界に存在する無限を物理世界の有限なリソースしかないコンピュータで計算するのは不可能です。

**無限は「計算不可能」なのです。**

無限が「計算不可能」なのは、先行評価戦略であれ、遅延評価戦略であれ、同じなのですが、ここで我々が抱える問題は、 **先行評価では、プログラミングコードにあるものは全部が全部コンピューティグ（計算）してしまう**ので、

- プログラミングコードを実行すること＝即時に物理世界にマッピングすること、となってしまっている
- プログラミングコード＝物理的実体≠数学的実体なので無限は絶対に扱えない

だから、 *どっちにせよ命令型パラダイム（＝先行評価戦略を前提にしている、と言い切っても差し支えない）でアルゴリズム設計をするしかないんだよ！*という思考のしがらみです。

##遅延評価（callByNeed）では無限を扱える

脱アルゴリズムを目指す、宣言型パラダイムを指向するためには、

- プログラミングコード＝物理的実体≠数学的実体 の先行評価戦略

ではどうにもまずい。

そこで、 **遅延評価戦略**の出番です。

**遅延評価戦略**では、プログラミングコードにあるものを全部が全部コンピューティグ（計算）することはしない、必要な物だけ計算するという戦略を取ります。

そこで、こう考えてみてはどうだろう？

無限は宣言するが、けして計算しないし、してもどうせ計算できない（計算不可能だ）し、そもそも無限を計算する必要なんてどこにもない。

そうだ無限は計算する必要ないんだ。

必要ないものは、計算しないのが 遅延評価の戦略なのだから、問題は解決しているじゃない？

となる。

そもそもコードというのは数学的実体なのだから、その数学世界で、無限という数学的実体を宣言するのはなんら支障はないはずです。

支障があると思うのは、先行評価戦略でなんでもかんでも片っ端から計算してしまうやり方を当たり前のようにやって、数学的実体を安易にホイホイ物理世界にマッピングしてしまうからだろう？？それではダメだ！

ということです。

無限という数学的実体を有限なマシンにマッピング、展開するのは不可能ですが、
マッピングせずに、数学世界に属するプログラミングコードで宣言することは普通に可能です。

有限なリソースしかない物理世界に属するコンピューティングマシンで
数学世界の数学的実体である無限を扱うためには、
「コンピューティグ（計算）しない」という方法しかありません。そして
本来、プログラミングコードとは数学世界にのみ存在するので、原理的に、無限という数学的実体を普通に扱えて当然なのです。


##Lazy.js

JavaScript には、秀逸な遅延評価ライブラリ

Lazy.jsがあります。

http://danieltao.com/lazy.js/

>Lazy.js it a utility library for JavaScript, similar to Underscore and Lo-Dash but with one important difference: **lazy evaluation** (also known as deferred execution). This can translate to superior performance in many cases, especially when dealing with large arrays and/or "chaining" together multiple methods. 　

>Lazy.js は、JavaScriptのユーティリティライブラリで、UnderscoreやLo-Dash（*関数プログラム用ライブラリ）に類似しています。
しかし、一つ大きな違いがあり、それは **遅延評価** (あるいは、Deferredで知られています。 *jQuery.Deferredというのもある)です。

>これは多くのケースで、特に多くの配列を扱う際に秀逸なパフォーマンスを発揮する事ができ（*総当りの無駄な先行評価をしないから）、複数メソッドをまとめて「チェーン」することが出来ます。


Lazy.jsライブラリを導入すると、関数型かつ遅延評価でデータを扱うことができます。

つまり、より宣言型パラダイムでコーディングすることができ、無限を扱えるということです。

####Lazy.jsで、自然数という無限数列を宣言するのは、以下のコードです。


```
var _ = require('lazy.js');

var naturalF = function(n)
{
  return n;
};

var Natural = _.generate(naturalF); //自然数（の全部）（無限数列）
```

`_.generate` はある関数を引数にとり、その関数操作を一律、集合要素に適用するという2階建ての関数で、
これを関数型プログラミングは **高階関数(higher-order function)**と呼び、その他のmap,
reduceなども高階関数です。(高階関数はSwiftにも当然実装されている)

`_.generate`は、 **イタレータ**と呼ばれる特別な高階関数で、繰り返しながら一律、引数関数を要素に適用しながら集合を生成せよとする関数です。

`naturalF`はイタレータのインデックス`n`をそのまま返す関数なので、イタレータでインデックス`n`がインクリメント(+1)される度に、0,1,2,3,4,5..と自然数の集合が積み上がる仕組みです。

####ただし！　これは宣言しているだけで、実際に延々と無限に計算はされません。

遅延評価なので、とりあえず実行環境にはガン無視されます。だから自然数という無限数列が扱えるんですね。

しかし、あくまで数学的存在であるコードのなかで、こういう数学的構造がきっちりと宣言できています。

###【問題】０から９９９９までの数字を全部足して表示するコードを書け。（宣言形アプローチ）

```
var _ = require('lazy.js');

var naturalF = function(n)
{
  return n;
};

var Natural = _.generate(naturalF); //自然数（の全部）（無限数列）

var plus = function(a, b)
{
  return (a + b);
};

var result =
  Natural　 //自然数
.take(10000) //の最初の１００００項を取る
.reduce(plus); //それらすべての項目にplus関数を適用しReduceする

console.log(result); //49995000
```
(javascript + 関数型ライブラリ=lazy.js)

さて、
```
var result =
  Natural　 //自然数
.take(10000) //の最初の１００００項を取る
.reduce(plus); //それらすべての項目にplus関数を適用しReduceする
```

がキモです。注目してみましょう。

`Natural`はLazy.jsライブラリの文脈で定義した自然数という無限数列です。評価（計算）はされません。

`.take(10000)`はその最初の１００００項を取るという関数（メソッド）です。評価（計算）はされません。

`.reduce(plus);`  

それらすべての項目に`plus`関数を適用し`reduce`せよ！

この`.reduce`という関数が遅延評価のトリガーです。

これまでのところ、`Natural`であれ、`take(10000)`であれ、一切評価（計算）されず、実行環境にガン無視されていましたが、

この`.reduce`が解釈されるや否や、芋づる式の評価（計算）が波及開始されます。

念のために別の言葉で言い直すと、コードの数学構造が、有限な物理世界へマッピング開始されます。

まず`plus`という引数である関数が評価されて物理メモリにロードされます。

次に、`.reduce`のチェーン元は、`take`なので、必要になった

`take`という関数が評価され、さらにそれに必要な`10000`が評価されます。

これで、ライブラリの内部的には10000回`Natural`を操作しないといけないと解釈される。

必要になった`Natural`が参照されます。

`Natural`とはイタレータで定義された遅延オブジェクトであり、高階関数の引数の関数を参照すると、１ずつインクリメントされる数列なので、0から10000回、内部的にループがまわる。

行き着くところまで行って、すべての道具立てがそろい0-9999の数字が用意され、また集合要素の数だけplus関数が適用されるループがまわり、最終的な回答が得られる。

ライブラリの内部的にはこれだけの仕事を請け負っており、これは、「アルゴリズムの汚れ作業そのもの」と言って良いでしょう。

しかし、我々が必須だと考えていたこのアルゴリズムは、コードの表層からは完全に隠蔽されて、数学表現ほぼそのままにクリーンに簡潔に宣言的に表現されているのです。

これが「脱アルゴリズム」、宣言的パラダイムへの「指向」です。

要するに

###【問題】０から９９９９までの数字を全部足して表示するコードを書け。（宣言形アプローチ）

の回答コードとしては、

```
var result =
  Natural　 //自然数
.take(10000) //の最初の１００００項を取る
.reduce(plus); //それらすべての項目にplus関数を適用しReduceする
```

ただ単純にこう書きたい。

**アルゴリズムなんて存在しないので、バグが入り込む隙なんてどこにもないでしょ？**

ってことで、メンテナンス性が高いのも一目瞭然です。部品をチェーンで接続しているだけなのだから。


##フィボナッチ数列
　　
さて、世の中にはアルゴリズムアルゴリズムした難解な問題は山ほどあるのですが、その中でも結構有名なのが、

###フィボナッチ数列を求めよ

というものです。

フィボナッチ数列とは、

[Wikipediaの説明](http://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A3%E3%83%9C%E3%83%8A%E3%83%83%E3%83%81%E6%95%B0)

にあるとおりの数列ですが、

`1`からはじまり、
```
1+1 = 2
1+2 = 3
2+3 = 5
3+5 = 8
5+8 = 13
8+13 = 21
13+21 = 34
21+34 = 55
.........
```

と、前項２つを足して積み上がる構造をもつ数列です。

この数列がなんで、そんなに特別視されているのか？

というと、これは数学の対称性の中でも「 **比率の対称性**を司る数列」数値だからです。

数学の対称性とは、人間の主観である「美」と関係があります。

例えば、音楽って突き詰めれば数学の対称性を人間の耳と脳が「美しい」と感じるもので、たとえば、純正律では、「ド・ミ・ソ」の和音というのは、周波数が4：5：6のの整数比になっていたりします。

フィボナッチ数列は、上記の計算の直近の２項を取り上げてみると、

`34`と`55`ですが、比率を計算してみると、

1:1.1617647....

となり、

もうひとつ次の項は、

34+55 = 89

で、　`55`  `89`  の比率は、

1.6181818...

で、　

55+89 = 144

で、　`89`  `144` の比率は、

1.61797...

と、いうように、２項、前後の比率が、
1.6180.....
に収束していきます。

２項前後の比率がこのように一定ということは、フィボナッチ数列の比率でとった線を拡大しても縮小しても、どんな縮尺でもオリジナルと寸分違わない線のグループになります。

これが **黄金比** ですね。
黄金比は自己相似で自己の比率において対照であり、比率が不変です。

ためしに、
黄金比

1.6180339887....

の逆数　1わる黄金比を計算してみると、

0..6180339887....

と小数点以下が無限にぴったりと一致します。

このようにフィボナッチ数列は、数学世界において、比率の対称性を司る特別な存在であり、対称性とは即ち「美」であり、黄金の比率を持つ美しい数列は、ちょっと求める価値が大いにあるだろう！というのが、フィボナッチ数列がアルゴリズム問題で例題に取り上げられる特別な理由です。

あともうひとつ重要な理由があるのですが、ネタは後でバラします。


フィボナッチ数列を求める、もっともプレーンな教科書的な解法、アルゴリズムは`再帰`(Recursion)を用いるものです。

```
var fib = function(n)
{
  if (n <= 1)
   return 1;
  else
   return fib(n-1) + fib(n-2);
}
for (var n = 0; n < 10; n++) console.log(fib(n));
```

このJSコードを、ブラウザのコンソールで同様に実行してみると、

```
1
1  
2  
3  
5  
8  
13  
21  
34  
55
```
と確かに、フィボナッチ数列、10項が計算されて表示されます。

素晴らしい、何の問題もないように見えます。

では、次に10項ではなく100項を計算してみましょう。

```
var fib = function(n)
{
  if (n <= 1)
   return 1;
  else
   return fib(n-1) + fib(n-2);
}
for (var n = 0; n < 100; n++) console.log(fib(n));
```

PCのCPUの使用率が跳ね上がり、Chromeブラウザが反応しなくなりました。

だからやらないほうが良いです。

仮に100がクリアできても1000,10000とオーダーを上げると確実に死亡します。

理由は、このアルゴリズムは、１ループ毎に指数関数的に計算量が増えていくからです。


同様に、遅延評価でやってみます。

```
var fibF = function()
{
  var seq = []; //build sequence array in this closure
  var f = function(n)
  {
    var val;
    if (n <= 1)
    {
      val = 1; // as the Fib definition in Math
    }
    else
    {
      val = seq[n - 2] + seq[n - 1]; // as the Fib definition in Math
    }
    seq[n] = val;
    return val;
  };
  return f;
}();

var Fib = _.generate(fibF);//フィボナッチ数列（無限数列）（計算しない）

var fib_1000 =
  Fib
  .take(1000)　//1000項取る（計算しない）
  .toArray();　//配列に書き出す（物理世界へマッピングする評価、計算開始のトリガー）

console.log(fib_1000); //[ 1, 1, 2, 3, 5, 8, 13, 21, 34, 55,...........,4.346655768693743e+208 ]

```

これは、「メモ化」のテクニークを適用するためクロージャが組み込まれていますが、

本当は、そういう自明なアルゴリズム要素は、ライブラリに肩代わりしてもらって隠蔽して、


```
var _ = require('lazy.js');

var fibF  = function(n)
{
    if (n <= 1)
    {
      return 1; // as the Fib definition in Math
    }
    else
    {
      return _.this(n - 2) + _.this(n - 1);   // as the Fib definition in Math
    }
};

var Fib = _.generate(fibF);//フィボナッチ数列（無限数列）（計算しない）

var fib_1000 =
  Fib
  .take(1000)　//1000項取る（計算しない）
  .toArray();　//配列に書き出す（物理世界へマッピングする評価、計算開始のトリガー）

console.log(fib_1000); //[ 1, 1, 2, 3, 5, 8, 13, 21, 34, 55,...........,4.346655768693743e+208 ]

```

こう書きたい！という要望を目下、作者の人に要請しています。


##FRPと遅延評価（CallByNeed）は本質的に同じものであり、FRPは時間軸上の無限データを扱う

さて、これまで、遅延評価（Lazy Evaluation）（CallByNeed）で宣言的に無限を扱う解説をしてきました。

前回は関数リアクティブプログラミング（FRP）の導入でしたが、そこで「時間軸上のイベント」を数学データとして扱う、宣言型パラダイムの話をしました。

今回の **遅延評価（Lazy Evaluation）（CallByNeed）**

と

前回の **関数リアクティブプログラミング（FRP）**

が本質的に等価なのはわかるでしょうか？

FRPの「時間軸上のイベント」っていうのは、そもそも「計算不可能」なんですよね。

**時間軸は、数学の無限数列が横たわる数直線の軸と一緒で、無限**です。

付け加えると、我々が既知のデータとして計算できるのは、時空の中でたかだか過去から現在までであって、未来のデータは未知なので計算できません。

つまりFRPって手法として計算不可能な無限を宣言的に取り扱っている。

これを説明して、理解してもらうためには、今回の遅延評価の理解がないと多分ムリなので、前回はその話まではしませんでした。

http://en.wikipedia.org/wiki/Reactive_programming

には

>In computing, reactive programming is a programming paradigm oriented around data flows and the  **propagation of change**.

**変化のプロパゲーション** とあります。

**propagationとは、（増殖的に）伝播、波及という意味**ですが、これ要するに、 **遅延評価のCallByNeedの必要な部分をトリガーとして芋づる式に伝播、波及していくという構造と等価**なのです。

FRPにおけるイベント処理とは、時間軸上に無限に広がるイベント群を、そっくりまるごとデータとして処理することでした。

FRPとは、時間軸にCallByNeed(遅延評価)を適用し、時間変化に伴うイベントをトリガーとして、評価していく戦略だと言ってよいでしょう。

時間軸上を時系列になぞりながら移動する我々の視点（その瞬間、その時間軸上のある1点の3次元世界）からは、この無限数列を先行評価するのは絶対に不可能なので、そのイベントが発生した点でCallByNeed(遅延評価)する、別の言い方をすると、その瞬間に数学的実体を物理世界にマッピングする、コンピューティグ（計算）するのです。
この現象をプロパゲーション（波及）と表現しているのですが、遅延評価戦略です。

####論より証拠、FRPと遅延評価の類似性をコードで例証してみましょう。

これまで紹介してきた、JSの

- **遅延評価ライブラリ　lazy.js**
- **FRPライブラリ Bacon.js**

を適用します。

```
var _ = require('lazy.js');
var B = require('baconjs');

var NaturalF = function(n)
    {
      return n;
    };
var numberSequence = _
      .generate(NaturalF) //自然数（無限数列）　数学世界　計算不可能
      .take(10); //有限数列になり計算可能になったが、計算せずに数学世界を維持（遅延評価＝CallByNeed）

var timeSequence = B
      .interval(1000) //時間軸（無限の列）数学世界　計算不可能 時間軸上の1000ms(1秒)間隔のイベントをデータの集合として定義
      .take(10); //時間軸上の有限の列になったが、いずれにせよ時間軸上のこの瞬間において未来のデータを含むので計算不可能　数学世界を維持（遅延評価＝CallByNeed）


//数学世界　⇒　物理世界　　　計算（コンピューティング）

var numbers = numberSequence //数学世界
    .toArray(); //物理世界にマッピングする＝計算（コンピューティング）

    console.log(numbers); //0-9 までの10個の自然数が出力される

timeSequence //数学世界
    .onValue(function() //物理世界にマッピングする＝計算（コンピューティング）
      {
        console.log(require('moment')().format('MMMM Do YYYY, h:mm:ss')); //時間の流れ（時間軸上を未来方向へ移動）に従って、毎秒タイムスタンプが10回、出力される
      });

```

ポイントは、

数学世界の数直線上の`numberSequence`であれ、

数学世界の時間軸上の`timeSequence`であれ、

同等に、無限の数学的実体として定義する。遅延評価（CallByNeed）なのでそのまま評価（計算、コンピューティング）されずに、数学的実体のままコード上で宣言、表現できる。

`numberSequence`についてはすでに解説は不要でしょう。

`timeSequence`ですが、FRPライブラリのBacon.jsをもって、時間軸上の1000ms(1秒)間隔のイベントをデータの集合として定義しています。

こういう時間軸上のデータのことを、巷では特に **ストリームデータ** あるいはBacon.jsでは **イベントストリーム**と呼ぶようです。

`timeSequence`を `.take(10)`します。

`numberSequence`の自然数から `.take(10)`で数直線上の10個の数値を切り出すのとまったく同じ作法である事に注目してください。

時間軸上で、現在を起点つまり原点０として、そこから未来方向へ10個分のイベントデータ、この場合は毎秒間隔に発生するタイムイベントを切り出しています。

未来のデータを先取りしていることになりますが、あくまで遅延評価戦略で必要になるまで評価（計算）しない、物理世界にマッピングせず数学世界に捨て置くので何の問題もありません。


そして、

`numberSequence`　の　`toArray` が有限な物理世界の実行環境にとって無限の数学的実体を物理世界にマッピング開始する（評価開始）トリガーであり、

`timeSequence`の時間軸上では、`onValue` が有限な物理世界の実行環境にとって無限の数学的実体を物理世界にマッピング開始する（評価開始）トリガーです。

`timeSequence`の時間軸上では、時間の流れ（時間軸上を未来方向へ移動）に従って、「予約していた未来のイベント」が発火すると同時に、プロパゲート開始されるので、結果的に、毎秒タイムスタンプが10回、出力されることになります。

##脱アルゴリズムのためのまとめ　宣言型パラダイムへのアプローチ

####宣言型パラダイムは、煩雑でバグのリスクが多い保守が困難なアルゴリズム、フローチャート設計を言語仕様やライブラリに肩代わりさせ、コードの表層から隠蔽し、数学的表現をそのまま簡潔にコードに表現し、バグフリー、保守性が高いコーディングを実現するための方法論です。

そのために必要なのは、

####1. 関数型プログラミング言語
####2. 関数リアクティブプログラミング（FRP）
####3. 遅延評価

が必須である、ことを解説しました。



#### KenOKABE tech blog
####[←ブログコンテンツ](http://kenokabe.github.io/contents/entries/entry0/entry.html)
