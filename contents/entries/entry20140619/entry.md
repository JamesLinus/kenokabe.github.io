## 関数リアクティブプログラミング（FRP）で分断された2つの世界を繋ぐ【脱アルゴリズム宣言②】

#### KenOKABE tech blog
####[←ブログコンテンツ](http://kenokabe.github.io/contents/entries/entry0/entry.html)


前回の[ブログ記事](http://kenokabe.github.io/contents/entries/entry20140611/entry.html)
[Swiftで脱アルゴリズム！iOS開発を関数型（宣言型）プログラミングへパラダイムシフトしてみる【脱アルゴリズム宣言①】](http://qiita.com/kenokabe/items/41189c45001321c9e283)

では、命令型（手続き型）、宣言型（関数型その他）プログラミングパラダイムについて解説しました。

####物理世界　--コーディング（モデル化）-->　数学世界　--コンピューティング（計算）--> 　物理世界


##遅延評価あるいはLazy Evaluation というわかりにくいネーミング

まったくイメージがわかないです。私もこのネーミングで理解するのに苦労したと思います。

遅延評価あるいはLazyEvaluationには別の呼び方があって、

Call By Need　 http://ja.wikipedia.org/wiki/%E8%A9%95%E4%BE%A1%E6%88%A6%E7%95%A5#.E5.BF.85.E8.A6.81.E5.91.BC.E3.81.B3
では「必要呼び」と訳されている。


##FRPとCallByNeedは本質的に同じものであり、FRPは時間軸上の無限データを扱う

FRPのプロパゲーションは、あるイベント発生を起点として、波のように広がっていく
波及ですが
CallByNeedは本質的に同じものです。

FRPとは、時間軸にCallByNeed(遅延評価)を適用したものです。



無限という数学的実体を有限なマシンにマッピングするのは不可能ですが、
マッピングせずに、数学世界に属するプログラミングコードで宣言することは普通に可能です。


有限なリソースしかない物理世界に属するコンピューティングマシンで
数学世界の数学的実体である無限を扱うためには、
「コンピューティグ（計算）しない」という方法しかありません。

先行評価では、
プログラミングコードにあるものは全部が全部コンピューティグ（計算）してしまうので、
プログラミングコードを実行＝即時に物理世界にマッピングとなってしまっている、
プログラミングコード＝物理的実体≠数学的実体なので無限を扱えません。

しかし、本来、プログラミングコードとは数学世界にのみ存在するので、原理的に、無限という数学的実体を普通に扱えるのです。


自然数をCallByNeed(遅延評価)で扱えるのは、数学世界にあるプログラミングコード上で定義、宣言はするが、数学的実体を物理世界にマッピングはしない、コンピューティグ（計算）しないからです。

同じように、FRPにおけるイベント処理とは、時間軸上に無限に広がるイベント群を、そっくりまるごとデータとして処理することでした。

時間軸上を時系列になぞりながら移動する我々の視点（その瞬間、その時間軸上のある1点の3次元世界）からは、この無限数列を先行評価するのは絶対に不可能なので、そのイベントが発生した点でCallByNeed(遅延評価)する、別の言い方をすると、その瞬間に数学的実体を物理世界にマッピングする、コンピューティグ（計算）するのです。
この現象をプロパゲーション（波及）と表現しています。




#### KenOKABE tech blog
####[←ブログコンテンツ](http://kenokabe.github.io/contents/entries/entry0/entry.html)
