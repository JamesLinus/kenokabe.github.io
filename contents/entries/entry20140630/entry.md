
#### KenOKABE tech blog
####[←ブログコンテンツ](http://kenokabe.github.io/contents/entries/entry0/entry.html)

#記事シリーズ
#### [Swiftで脱アルゴリズム！iOS開発を関数型（宣言型）プログラミングへパラダイムシフトしてみる【脱アルゴリズム宣言①】](http://qiita.com/kenokabe/items/41189c45001321c9e283)
####  [関数リアクティブプログラミング（FRP）で分断された2つの世界を繋ぐ【脱アルゴリズム宣言②】](http://qiita.com/kenokabe/items/a8477694a499ca869cde)
#### [関数型（宣言型）プログラミングで無限をコーディングする「遅延評価」のわかりやすい解説【脱アルゴリズム宣言③】](http://qiita.com/kenokabe/items/821ce4020644372b648c)

#### [LISPデータ構造の問題点と抜本的な解法としての新プログラミング言語の策定　純粋関数型言語「SpaceTime」 ドラフト](http://qiita.com/kenokabe/items/aa5705978d6a13753fe2)

#### [遅延評価(Lazy.js)とFRP(Bacon.js)とJavaScriptで時空なんでもマッピング！【時空プログラミング①】](http://qiita.com/kenokabe/items/b04e3d8d49b0ffc7a78b)

#### [タイマーを無限個作り、データとして取り回す【時空プログラミング②】](http://qiita.com/kenokabe/items/8c970d2b0dfa98187998)

#### [自然数と自然数+1 で偶数と奇数を作る【時空プログラミング③】]( http://qiita.com/kenokabe/items/f6172df8d8416429656a)

#### [数学と別離したプログラミング、時間を抽象化し数学を取り戻すプログラミング【時空プログラミング④】](http://qiita.com/kenokabe/items/b81c7aa8af86314551a0)

#数学と別離したプログラミング、時間を抽象化し数学を取り戻すプログラミング【時空プログラミング④】


この記事は、先立つ【脱アルゴリズム宣言】を読了している読者を想定して書かれています。

さて、今回は、「時空プログラミング」と冠して、大きな花火をぶち上げています。

**時空をプログラミングする** っていうと「こりゃまた大風呂敷を広げたな」と思う人がきっと多いでしょう。

しかしかしながら、実際のところ、プログラミングパラダイムの変遷とは 究極的に **時空をプログラミングする** という一大哲学的目標に向けて進化し続けてきたと言ってもけして過言ではありません。(念のためですが、「時空」と言ってもニュートン的世界観の時空です、アインシュタインの相対性理論以降の時間と空間が入り交じるあの時空までは想定していません)

本稿ではそのことについて書きます。


[コンピュータ・サイエンス](http://ja.wikipedia.org/wiki/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%A6)
によれば、
>計算機科学という名前にも関わらず、計算機科学の研究対象は物理的な電子計算機そのものではない。例えば著名な計算機科学者エドガー・ダイクストラは「天文学が望遠鏡に関する学問でないのと同様に、計算機科学はコンピュータに関する学問ではない」という言葉を残している。コンピュータの設計と開発は計算機科学の領域外の話である。例えばハードウェアは計算機工学の領域であるし、商用コンピュータシステムとその利用は情報技術とか情報システムと呼ばれる。ただし、コンピュータのハードウェアはその計算手法と密接な関係にあり、応用技術のなかにも計算機科学の対象となる部分がある。また、計算機科学と他の周辺学問分野との間では新たな学問がいくつも生まれている。計算機科学と関係の深い学問分野として、哲学、経済学、数学、物理学、言語学などを挙げることができる。

>一部の人々は計算機科学は数学と最も関連が深いとみなしている[7]。初期の計算機科学はクルト・ゲーデルやアラン・チューリングなどの数学での業績に強い影響を受けていたし、数理論理学、圏論、領域理論、代数学といった領域は計算機科学と数学の間でアイデアをやり取りする領域となっている。

>計算機科学とソフトウェア工学の関係は論争の的である。「ソフトウェア工学」という言葉が表すものが何か、計算機科学の範囲をどう定めるかは長年の議論の対象となっている。一部の人々はソフトウェア工学が計算機科学の一部であると信じている。他の人々は、計算機科学が計算全般を扱う学問であるのに対して、ソフトウェア工学は実用的な目的でコンピュータ処理を設計するものであり、異なる学問分野であると考えている。この見方の例としてデイビッド・パーナスがいる[10]。他の人々はソフトウェアは全く工学的に扱うことはできていないと考えている。

- 計算機科学の研究対象は物理的な電子計算機そのものではない

- 計算機科学の理論的基盤はもちろん数学である

- 「ソフトウェア工学」とは計算機科学を応用する工学（エンジニアリング）である

だいたいこんな感じで、明確なコンセンサスには至っていない、というのが読み取れます。

コンピュータサイエンス、ソフトウェア工学とは学際分野であり、明確な概念化が難しいのでしょう。

本稿も、数学、科学、工学、そして哲学と学問領域をクロスオーバーします。

**時空をプログラミングする**というフレーズは、端的に、数学、科学、工学、哲学をまたぐ学際的作業を試みているから、こういう表現になるでしょう。

- 計算機科学の研究対象は物理的な電子計算機そのものではない

- 計算機科学の理論的基盤はもちろん数学である

数学の理論的基盤を物理的な計算機で展開する、この工学的手法がプログラミングです。

この点を【脱アルゴリズム宣言】シリーズでの説明を振り返ると、

####物理世界　--コーディング（モデル化）-->　数学世界　--コンピューティング（計算）--> 　物理世界

なのですが、物理世界を数学世界へ、そして、数学世界を物理世界へ展開する工学手法として、これまでのところ、物理マシンとしてのコンピュータによる物理的な処理プロセス、ステップByステップの命令型（手続き型）パラダイムの束縛からなかなか脱却できないままでいました。

プログラミング言語は、機械語、アセンブリ、フォートラン、LISP、C言語、C++、Javaなどなど徐々に物理的な処理プロセスから「高級言語」へと（数学的に）抽象化されいったのですが、特に、実務的なプログラミング作業では、これまで命令型（手続き型）パラダイムが主流となっていました。

実務的プログラミングの世界では、ほぼすべてのケースにおいて、非同期な入出力を扱うことになり、非同期な入出力（IO）は数学的に抽象化することが極めて困難なシロモノだからです。

つまり、

####物理世界　--コーディング（モデル化）-->　数学世界

の部分で完全に壁にぶち当たっており、それに連動する形で、

####物理世界　--コーディング（モデル化）-->　数学世界　--コンピューティング（計算）--> 　物理世界

という全体像をもつソフトウェア工学はたいへん大きな問題を抱えており、そのまま今日に至ります。

##数学のように見えて数学ではないプログラミングとの出会い

私が初めてプログラミングしたのは、小学校4年の頃で、電卓以外ではじめて触ったコンピュータは父親が仕事に使うことを見越して家に買って帰ってきたHITACHIのBASICマスターというパソコンでした。

今も昔も変わらないな、と思うのですが、子供はゲームに夢中です。
どうもこのパソコンっていうのは自分でプログラムを打ち込むとゲームができるらしい、ということがわかりました。
近所の本屋に行くと[マイコンBASICマガジン](http://ja.wikipedia.org/wiki/%E3%83%9E%E3%82%A4%E3%82%B3%E3%83%B3BASIC%E3%83%9E%E3%82%AC%E3%82%B8%E3%83%B3)、知る人ぞ知る、通称「ベーマガ」が積み置かれていました。興奮して早速購入し、BASICの「プログラムリスト」（ソースコード）を打ち込みました。

そこで頻繁に目にするのが、ゲーム画面上のキャラクターの座標をひとつ移動させるときにある変数の値を1つ増やす（インクリメントする）ための命令である、

```
X = X + 1
```

でした。
実にありふれたコードです。

この頃はまだ、小学4年だったので、算数の授業では「方程式」と言うのを習っておらず、何の疑問も抱かなかったのですが、中学に進学し、数学の授業で「方程式」の概念を習うと、

```
X = X + 1
```

というのは数学の方程式としては成り立たない、ということがわかりました。

「なるほど、どうやら、数学の方程式と、プログラミングでは様子が違うようだ」

と気がつきました。

同時に、数学の方程式の授業で「代入」というのを習いましたが、

数学の方程式の代入が、

- 式や関数に含まれる文字や変数を、数や他の文字や式で置き換えること

であることに対して、

プログラミングの代入は

- 変数の値を設定（ないし変更）すること（assignment）

という命令であり、

同じ数学的な言葉「代入」の意味がぜんぜん違う！ということに気が付きました。

愕然とした、というよりは、「なんかこれは後々ややこしい混乱を招くに違いない」「面倒を抱えた」と本能的な不快感を覚えました。

「代入」にはふたつの異なる意味がある。

http://ja.wikipedia.org/wiki/%E4%BB%A3%E5%85%A5

結果として、これが数学という本質的に宣言型パラダイムを認識し、自分がそれと異なる命令型パラダイムにいると、当時ぼんやりとではありますが自覚した瞬間だったと言えるでしょう。

しかし、その頃私はすでにコンピュータの動作原理などはおおよそ理解していたので、これはマシンを操作していく上で、原理的に回避できない問題であり、コンピュータでプログラミングするには、宣言型である数学ではない、命令型パラダイムでステップByステップの変数への代入操作を繰り返していくしか無い、と思っていました。それがプログラミングなのだと。

##プログラムの数学世界の破綻と数学世界への決別


命令型プログラミングにおける代入はまさに、 **破壊的代入** と呼ばれたりします。

BASICがポピュラーだった頃、Cが登場してもてはやされていた頃のプログラマーは、ごく一部のコンピュータ科学の研究者をのぞいて、ほぼ全員この踏み絵を踏まされていたのです。

当時、命令型プログラミングとは、実務やゲームのプログラミングにおいて唯一無比の、他に選択肢のないデフォルトのパラダイムでした。


しかし、その頃も我々ホビープログラマーが関知もしていないところで、一部の研究者たちは、関数型プログラミング言語の研究を粛々と進めていました。

関数型言語でもっとも古株はLISPで、随分昔からあります。

1950年代後半-1960年代半ば、高級言語が開発、発表されました。

最初がFORTLANで、LISPはその次に開発された言語です。
その後、COBOL,BASICと続きます。

LISPはその他Schemeへと派生し、現在もそれなりに広く使用されているようですが、実務で使用されているケースはあまり聞いたことはありません。　
これまで関数型言語であるが故に、宣言型パラダイムであるが故に、入出力の取扱の問題が大きく、実務用途には使いにくかったのです。
それと同時に、関数型言語のような宣言型パラダイムで抽象化した記述を処理するには当時のコンピュータの処理能力ではオーバーヘッドが大きく処理能力の低下が厭われました。
高級言語でありながらマシン語と直結するようなコンピュータ寄りの言語仕様パラダイムで効率のよいコンパイル結果をもたらすC言語は、その処理速度の速さで人気を集めました。

ちなみに、私はLISPとSchemeを結構触ってみましたが、結果的にあまり好きになれませんでした。
言語構造としてポテンシャルが高いのはよくわかるが、触れば触るほど不満が高まり、もうどうしようもないので、一念発起しLISPを全面的に書き直すというか、新しいプログラミング言語を書いてしまいました。
それについては、とても長くなるので別記事。

##### LISPデータ構造の問題点と抜本的な解法としての新プログラミング言語の策定　純粋関数型言語「SpaceTime」 ドラフト
####[プロジェクトサイト動作デモ](http://spacetimeprogramminglanguage.github.io/)
####[Qiitaの記事](http://qiita.com/kenokabe/items/aa5705978d6a13753fe2)

LISPは関数型言語で、かなりの程度、宣言型ですが、命令型パラダイム＝非宣言型パラダイムの呪縛からは逃れられませんでした。

##数学世界をプログラミングの世界に取り戻す

####物理世界　--コーディング（モデル化）-->　数学世界

のプロセスで非同期な入出力（IO）を数学的に抽象化する問題は解決していませんでしたが、バグフリーで保守性の高い簡潔なコードを実現するための宣言型パラダイムを実装するためには、先行評価ではなく、遅延評価(CallByNeed)戦略を採用することが重要だと明らかになってきました。

[関数型（宣言型）プログラミングで無限をコーディングする「遅延評価」のわかりやすい解説【脱アルゴリズム宣言③】](http://qiita.com/kenokabe/items/821ce4020644372b648c)参照のこと

関数型言語が命令型パラダイムから大きく脱却したのは1990年前後であり、それを象徴するのが **遅延評価戦略**を採用した [純粋関数型言語](http://ja.wikipedia.org/wiki/%E9%96%A2%E6%95%B0%E5%9E%8B%E8%A8%80%E8%AA%9E) である [Haskell](http://ja.wikipedia.org/wiki/Haskell)の登場でした。

>1977年、FORTRANの設計とBNFの発明の業績でこの年のチューリング賞を受賞したジョン・バッカスは、Can Programming Be Liberated From the von Neumann Style?: A Functional Style and Its Algebra of Programs[3]と題した受賞記念講演で関数型プログラミングの重要性を訴えた。講演ではFPという関数型言語の紹介もした（サブタイトルの後半の「プログラムの代数」はこれを指す）が、これはAPL（特に、高階関数の意味がある記号（APLの用語ではoperator（作用素）という））の影響を受けている（APL自体はふつう関数型とはされない）。

>バッカスのFPは広く使用されることはなかったが、この後関数型言語の研究・開発は広まることとなった。1985年にMirandaが登場した。1987年に、遅延評価の純粋関数型言語の標準の必要性が認識されHaskellの策定が始まった。1990年にHaskell 1.0仕様がリリースされた。同じく1990年にはMLの標準であるStandard MLもリリースされている。

>1985年、遅延関数言語である Miranda がリサーチ・ソフトウェア社によって発表された。1987年にはこのような非正格な純粋関数型プログラミング言語が十二以上存在していたが、そのうち最も広く使われていた Miranda はパブリックドメインではなかった。オレゴン州ポートランドで開催された Functional Programming Languages and Computer Architecture (FPCA '87) において開かれた会議中に、遅延関数型言語のオープンな標準を作成するための委員会が発足されるべき、という強い合意が参加者のあいだで形成された。委員会の目的は、関数型言語のデザインにおける将来の研究のための基礎として役立つ共通のものへと、既存の関数型言語を統合することであった[2]。

>Haskell 1.0
>最初の版の Haskell（Haskell 1.0）は1990年に作成された[3]。委員会の活動は一連の言語仕様を結果に残し、1997年後半にそのシリーズは、安定しており小さく可搬なバージョンの言語仕様と、学習用および将来の拡張の基礎としての基本ライブラリなどを定義したHaskell 98 に到達した。実験的な機能の付加や統合を通じて Haskell98 の拡張や派生物を作成することを、委員会ははっきりと歓迎した[2]。

##純粋関数型言語 (Pure functional language)

関数型言語については、【脱アルゴリズム宣言】シリーズで導入しましたが、

**純粋関数型言語**とは、宣言型パラダイムをより完全に実装するプログラミング言語のことです。

JavaScriptやSwiftは関数型言語ですが、純粋関数型言語ではありません。
デフォルトで遅延評価ではないからです。

JavaScriptで、遅延評価の能力を発揮し数学世界の無限を扱えるようにした **lazy.js**ライブラリを導入しましたが、Javascriptの言語仕様としてはデフォルトで先行評価戦略です。

デフォルトで遅延評価戦略を取る純粋関数型言語では、どうなるか？と言うと、

```
X = X + 1
```
というような数学世界の破綻がなくなります。


数学の方程式の代入とは、

- 式や関数に含まれる文字や変数を、数や他の文字や式で置き換えること

でしたが、純粋関数型言語においては、 **純粋関数型言語における代入＝数学における代入** と意味が一致します。

すなわち、

- 変数の値を設定（ないし変更）すること（assignment）

という、BASIC時代で愕然とした **命令型パラダイムの「代入」あるいは「破壊的代入」は禁止**されます。


仮に、遅延評価型言語で、後者の命令型パラダイムの「代入」あるいは「破壊的代入」が行われたとしたら、どうなるでしょうか？
ちょっと確認してみましょう。

####もしもJavaScriptが遅延評価型言語で、破壊的代入が許されたならば？

```
var a;

a = 3; //代入 置き換え？束縛？いずれにせよ、次に破壊的代入

a = 5; //破壊的代入
　
console.log(a);
```

遅延評価（CallByNeed） 戦略なので、

最初のａの宣言部分は全部ガン無視で、

`console.log(a);`

がトリガーとなって、必要となった引数`a`がはじめまて引っぱり出されるのでした。

そして、遅延評価（CallByNeed）戦略なので、コードの前後は評価順序とは関係ありません。

さて、`a`を定義している部分が2箇所あります。果たしてどっちを選べばいいのでしょう？

矛盾した`a`が2つある！と遅延評価戦略のポリシーが崩壊します。

故に、コードの前後が評価順序と無関係な遅延評価（CallByNeed）戦略においては、論理体系の整合性を取るために、破壊的代入は禁止されます。

遅延評価を言語レベルでデフォルトにしている純粋関数型言語では、変数の宣言とは数学世界の変数の宣言、代入とまったく同じ意味になります。


##参照透過性（Referential transparency）


命令型パラダイム、先行評価戦略の世界では破綻していた数学世界がプログラミング世界に戻ってきました。

このような数学世界では当たり前の状態をプログラムの世界では特に、

**参照透過（Referential transparent）**である、といいます。

> **参照透過性（さんしょうとうかせい、英: Referential** transparency）は、計算機言語の概念の一種で、文脈によらず式の値はその構成要素（例えば変数や関数）によってのみ定まるということを言う。具体的には変数の値は最初に定義した値と常に同じであり、関数は同じ変数を引数として与えられれば同じ値を返すということになる。当然変数に値を割り当てなおす演算である代入 (Assignment) を行う式は存在しない。このように参照透過性が成り立っている場合、ある式の値、例えば関数値、変数値についてどこに記憶されている値を参照しているかということは考慮する必要がない、即ち参照について透過的であるといえる。

>参照透過性が成り立つ言語は式の値がプログラムのテキストから定まるという特徴から **宣言型言語 (Declarative language)** と呼ばれたり、 **関数の数学的性質が保たれる**という特徴から **純粋関数型言語 (Pure functional language)** と呼ばれたりする。一方変数の値の変更が認められているような参照透過的でない言語を手続き型言語と呼ぶ。ただ、手続き型言語は機械語プログラミングとの繋がりという歴史的な事情により手続きが式でなく命令列で表現されたことから命令型言語と呼ばれることもあり、そのような場合との対比で単に式（例えば関数や変数の組み合わせ）でプログラムが表現されているだけの言語、あるいは高階関数の仕組みを備えた言語をひっくるめて、代入が可能であるかないかを問わず、関数型言語と呼ぶことも多いので注意が必要である。結局現状では単に関数型言語という場合は参照透過的な言語（即ち純粋関数型言語）とそうでない関数型言語を両方とも含むということになっている。



**参照透過（Referential transparent）**

**宣言型言語 (Declarative language)**

**純粋関数型言語 (Pure functional language)**

それから「破壊的代入の禁止」

初見では、いったい何を意味しているのかわかりにくい、取っ付きにくい用語が続出しますが、何の事はない、これらのすべては、

####整合性のある数学世界が数学的実体であるプログラミングコードで実現できることが保証されている、というただひとつの簡潔な性質を表す言葉なのです。

そして、何故こういう言葉が成立したのか？というと、

>ただ、手続き型言語は機械語プログラミングとの繋がりという歴史的な事情により手続きが式でなく命令列で表現されたことから命令型言語と呼ばれることもあり

と言及もされていますが、

機械語＝手続き型（命令型）パラダイム　⇒　宣言型パラダイム

という物理的なコンピューティングマシンの命令的操作を、数学的な宣言で操作するという偉大な抽象化の歴史的経緯があるからです。

##副作用（Side Effect）　




>プログラミングにおける副作用（ふくさよう）とは、ある機能がコンピュータの(論理的な) **状態を変化させ**、それ以降で得られる結果に影響を与えることをいう。代表的な例は **変数への値の代入**である。

>例えば与えられた数字を二倍して返す機能"double"があるとする。

```
double: x -> 2*x
例:
4 <- double: 2
```

>このような機能では次のことが成立する。

- 同じ条件を与えれば必ず同じ結果が得られる
- 他のいかなる機能の結果にも影響を与えない

>このような性質を参照透過性という[1]。 **参照透過** な機能はそれ自身状態を持たないことで副作用と独立している。

>一方状態を持つ機能"add"を考える。addは外側の変数eを増加させて返すものとすれば:

```
add: x -> e:e+x
例:
e: 1
2 <- add:1
2 <- e
...
```

>のようになるだろう。このような機能では見えない所で条件を変化させてしまうために、参照透過性の一つ目の仮定が崩れ、また他のeを利用する機能の結果も変化させるので二つ目の仮定も成立しない。addは副作用を持つ機能である。

>副作用を伴う機能の例としては、I/O制御(write/print等)、上記addのように **破壊的代入**を行う機能などがある。ノイマン型のアーキテクチャは副作用を前提として動作するため、多くのプログラミング言語では変数の破壊的代入機能を持つ。一方関数型言語では原則として副作用を存在しないものとみなし、モナドなどの手法で抽象化している。

>機能が副作用を持たないことの利点は、いかなる状況でも常に同じ結果が得られるために、機能を純粋に **宣言型プログラミング**で定義でき、状況依存でのバグの発生が抑えられるということである[2]。反面副作用を持たない言語設計はノイマン型アーキテクチャと反りが合わず、効率の点で不利になることが多い。また単純な逐次処理を行う場合は状態を中心に命令的な思考をした方が扱いやすい場合がある。このためLISPやMLなどは原則として関数型ながら、副作用を許容する設計になっている。


- 状態変数（フローチャートでForループ制御するための変数 `i` とか）

- 破壊的代入（破壊的代入あるいは命令型プラダイムで当たり前とされた踏み絵の「代入」は状態変数のためにある　Forループの　i++  i=i+1 もそう）

- 状態の変化

- 副作用

以上は言葉の表現こそ違いますが、すべて同じ概念を違う切り口で表現しているにすぎません。

ようするに、数学世界の関数ではない、命令型プログラミングの世界で巻きおこる一切合切の命令の結果、数学世界の範疇外の作用のことを副作用と呼びます。

しかしながら、数学世界の範疇外が数学的実体としてのコードの中で起こるのですから、そこはもはや数学世界としては成立していない。
そこはすでに数学的に破綻した世界であるということになります。

状態変化、副作用のあるコードは数学的に破綻したコードである、と言い換えても良いでしょう。


##そもそも何故、破壊的代入があるのか？何故、副作用があるのか？

数学の世界が数学同様に参照透過な純粋関数型言語で取り戻されたのは良かった。

しかし、そもそも何故、破壊的代入があったのか？何故、副作用があったのか？

**必要だから**

です。

コンピュータとはそもそも何か作業をさせるための道具です。

道具に命令し、仕事をさせる。

入力があって、処理があり、出力がある。

数学世界の中で宣言が整合的になされたからといって、変化する外界からの非同期な入力、それを内部で処理するための状態の変化を禁止されたらたまったものではありません。

状態の変化を処理するために破壊的代入があり、副作用があるのです。

そして実際、理論先行で完成した純粋関数型言語Haskellにおいても、この副作用をどう処理するか？状態変化をどう扱うのか？という問題がありました。


##純粋関数型プログラミング、宣言型パラダイムで、状態変化をどう扱うか？

###Haskellが取ったアプローチ　「モナド」
Haskellが採用したアプローチは、[モナド](http://ja.wikipedia.org/wiki/%E3%83%A2%E3%83%8A%E3%83%89_(%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0))で、これは要するに、いかにうまいこと、純粋関数型の純粋な数学世界と現実世界をコンポーネントと分離しながら、お互いにやりとりするか？という方法でした。

###「モナド」が成功しているとは思えない　別のアプローチを考える　変化って何？

別のアプローチを考える。

そもそも「状態変化」ってなんだろう？

「変化」ってなんだろう？

変化する、というのは時間変化のことですよね？



##コード前後（上下）シンドローム
コード前後問題とか、コード上下シンドロームとか、私が呼称する現象があります。

破壊的代入により状態変化するコードを見てみましょう。

```
var a = 5;
var b = 2 * a;

console.log(a); //5
console.log(b); //10

a = 7;

console.log(a); //7
console.log(b); //10
```

**a = 5**　であり「同時に」 **a = 7**　であり、論理的に矛盾しており、数学世界が破綻しています。

え？論理的に矛盾していないと思いますか？別に問題ないと。

これが、論理的に矛盾していない、と思ってしまうのは、我々がすでに踏み絵を踏まされているからであって、こう考える（考えさせられている）からでしょう。

- `a=5` と　`a=7` と代入している「コードの中の場所が違う」ので、「同時」ではなく「タイミングが違う」。

- `a=5` よりも `a=7` と代入したほうが「コードの位置で後にあるので」、「タイミングは後になる」。

ここで「後」っていう表現がそもそもおかしい、空間的には「後」ではなく「下」です。

これは命令型パラダイムにおいて、もう我々が無意識に「コードの下」は「実行タイミングでは後」と、コードの表現の中に時間の概念を紛れ込ませているからです。

命令型では、先行評価では、コードの流れが重要で、上から下へ逐次的に実行される。

逐次的に実行されるので、コードの上は「先」で、コードの下は「後」だ。



次に、

```
var b = a * 2;
```

と数学の方程式「のような」代入命令があります。

しかし、この命令は、コードの上下、前後関係において、一度しか通り過ぎないので、それっきりで、この数学の方程式の関係が維持されることは担保されません。

コードの上下関係によれば、`a=7`のほうが下にあるので、後から`5`という値を上書きする破壊的代入がなされます。

そのとき、`b` は`10`のままで、

`b = a * 2`　

の関係は崩壊します。

もう何もかもがカオスです。

多くの場合、アルゴリズム設計とは、コードの上下を考え、時間前後を考え、そういうことをやっているわけです。

##純粋関数型言語はこれまで問題に無自覚だった

純粋関数型言語では、コードの数学性が担保され、コードの中に時間変化する要素の混入を徹底排除しました。

排除され行き場を失った変化はモナドで隔離されるという道をたどることになります。

隔離されたものの、本質的な「時間」という概念要素の取扱には無頓着なままでした。

##時間を抽象化し、数学世界の対象とする関数リアクティブプログラミング（FRP）

一方で、FRPでは、時間変化を数学概念化し、数学世界に統合します。
　
時間変化を数学概念化するということは、次元をひとつ引き上げ、物理学のように時空を俯瞰するということです。

物理学のように時空を俯瞰する形で時間も数学的な時間軸と捉え直すと、時間変化に伴う状態変化は単なる時間軸上の数列となり世界は静止します。

それはちょうど、動画を収録しているDVDの動画データが動的でなく静的なデータであるのとまったく同じです。

DVDの動画はプレイヤーで再生すると動いて見えますが、DVDに収録されているデータ自体は生産時に焼き付けられたまま最初からまるごと全部ありますよね？

静止した世界においては、すでに変化は変化でなくなってしまっている。モナドの圏論がどうのこうのと知恵を絞って数学世界で安全に隔離する対象ですらない、ということです。

##変化する値はすべて時間軸上の「ストリーム」という静的なデータである。

静止しているわりに「ストリーム」というワーディングは誤解を招くと思います。

FRPで、時空を俯瞰して静的なデータとして扱うアプローチにおいて、個人的にあまり好ましい表現だと思わないのですが、ストリームというのは歴史上結構この文脈で使用されてきたバズワードです。

実際に「動いている」のはデータではなく、時間軸上を未来方向へ移動する我々の世界、あるいは我々の脳が創発する「意識」のほうなのですが、とにかく静的なデータとしての「ストリーム」です。

##「ストリーム」は数学モデルで相互の関係性が宣言されており、変化するごとに自動的に再計算がプロパゲートされる

さて、FRPで宣言型パラダイムで実装したコードです。

念のために先に断っておく必要があるのは、

JavaScriptは、純粋関数型言語ではありません。

言語仕様として先行評価戦略であり、遅延評価やFRPはライブラリの影響下のみで展開されます。

だから、コードの上（前）のほうで「先に」各種ライブラリの宣言をしておく必要があるし、その辺の呪縛からは逃れられません。

しかし、ライブラリの影響下では、遅延評価、FRPをもって宣言的に処理されていきます。



```
var __ = require('baconjs');

var a = __.sequentially(5000, [5, 7]);
var b = a.map(function(x)
{
  return x * 2;
});

a.onValue(function(x)
{
  console.log(x);
});

b.onValue(function(x)
{
  console.log(x);
});

```

同様に、変数　`a` `b` がありますが、

`a` `b` の数値の変化はコードの上下とは無関係です。
変化つまり時間要素は、時間軸上のストリーム（データ）として、一元的に、FRPライブラリ（Bacon.js）の管理下にあります。

当然、コードの上下、前後にともなって破壊的代入というようなことはありません。
JavaScriptは純粋関数型言語ではありませんが、 **宣言型パラダイムでコードを書くときには**もうそういうことは **してはいけない** のです。

今回、変数`a`が変化するとき、`b`との関係、FRPライブラリを用いて宣言的にどうプログラミングするか？という実験ですが、

変化する、というのは時間変化ですよね？

時間変化は、時間軸上のストリームで、インターバルと配列データとして定義できます。

```
var a = __.sequentially(5000, [5, 7]);

```

がその定義で、

`a` というストリームは、5秒インターバル（幅）で、値`5`,`7`として時間軸上に点在しているデータである、という意味です。

次に、

```
var b = a.map(function(x)
{
  return 2 * x;
});
```

は`b = a * 2` という関係性を定義します。

これは「代入」ではなく、 **数学の方程式としての関係性**になります。

数学の方程式なので「常に」等価になります。

「常に」というのは、時間変化があろうと何があろうとも等価で、定義したとおりの関係性がずっと維持されることが保証されます。

これで数学モデルは完成ですが、仕上げに、時間が経過して、ストリームの時間軸上をどんどん未来方向へ移動していく我々の物理世界に、この数学モデルをマッピングしてやる必要があります。

それがないと、まさにこの数学的実体としてのコードは数学世界のみに完結し、我々の世界と無関係な存在のままで終わってしまうからです。

その物理世界へマッピングする定義が、以下のコードです。

```
a.onValue(function(x)
{
  console.log(x);
});

b.onValue(function(x)
{
  console.log(x);
});
```

すでに定義したストリーム`a`や`b`の時間軸上の要素位置と、我々の現在時間が一致した瞬間、つまり`onValue` になったら、その瞬間ストリーム上に位置する要素値を画面に表示せよ、という宣言です。

FRPライブラリの影響下で、

`a` の値の変化を定義しましたが、

`b`との数学的関係も同時に定義しているので、連動して自動的に`b`も変化します。

というのは、我々目線の「変化」の話法であり、時空を俯瞰するFRPの観点からは、そのような関係性になるように、あらかじめ、時間軸上のデータである、ストリーム`b`にマッピングして定義したのです。

##デモ（ブラウザ）
では、実際に、時間変化を数学モデルにしたコードを時間が流れる我々の物理世界にマッピング開始してみましょう。

http://jsfiddle.net/r2J6L/

##まとめ

このように、時間軸を数学世界にモデリングし、プログラミングでも時空を数学モデルとして俯瞰し、抽象化することで、コードの中の数学世界の整合性を維持しながら、

####物理世界　--コーディング（モデル化）-->　数学世界　--コンピューティング（計算）--> 　物理世界

が完成しました。

では、
####数学世界　--コンピューティング（計算）--> 　物理世界

この要素しかない、そもそも物理世界の時間と関係もないのに、入出力による値の変化でもなんでもないのに、ただ単にコードの上下関係のフローを制御する目的のためだけに状態が刻々とする状態変数はどうなのか？

そういうのは宣言型パラダイムでは **「最初から論外」**となります。

それこそが、

[Swiftで脱アルゴリズム！iOS開発を関数型（宣言型）プログラミングへパラダイムシフトしてみる【脱アルゴリズム宣言①】](http://qiita.com/kenokabe/items/41189c45001321c9e283)
で、
####問題】１から１０までの数字を全部足して表示するコードを書け。（命令形アプローチ）
という平易な例として導入し論じたことです。

![](http://kenokabe.github.io/contents/entries/entry20140611/img/flowchart.png)


以上のアルゴリズム、フルーチャートは、実質、大昔の機械語のそれとまったく同じです。

そしてこのような状態変数を当たり前に使うような命令型パラダイムにおける煩雑なアルゴリズム設計には保守性、デバッグの観点から本質的な弊害があり、それを克服し脱却すべく、これまでコンピュータサイエンス、ソフトウェア工学の分野で絶え間ない研究と実践が重ねられてきました。

以上時空プログラミングの講釈でした。



#### KenOKABE tech blog
####[←ブログコンテンツ](http://kenokabe.github.io/contents/entries/entry0/entry.html)
