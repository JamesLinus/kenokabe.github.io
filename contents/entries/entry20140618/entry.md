## 関数リアクティブプログラミング（FRP）で分断された2つの世界を繋ぐ【脱アルゴリズム宣言②】

#### KenOKABE tech blog
####[←ブログコンテンツ](http://kenokabe.github.io/contents/entries/entry0/entry.html)


前回の[ブログ記事](http://kenokabe.github.io/contents/entries/entry20140611/entry.html)
[Swiftで脱アルゴリズム！iOS開発を関数型（宣言型）プログラミングへパラダイムシフトしてみる【脱アルゴリズム宣言①】](http://qiita.com/kenokabe/items/41189c45001321c9e283)

では、命令型（手続き型）、宣言型（関数型その他）プログラミングパラダイムについて解説しました。

プログラミングのアルゴリズム、フローチャート設計が抱える根本的な問題点を示すために、
「１から１０までの数を全部足す」という問題を例示しました。

多くのプログラマーが最初に考えがちなのが、上手にアルゴリズム設計して計算させる、という方法なのですが、これは実は、「命令型プログラミングパラダイム」という、いわば「原始的」な手法であることを説明しました。

なぜ「原始的」なのに未だに一般的なのか？

思ったよりもプログラミング技術の進歩は遅い、今現在まだいろいろな理由で機が熟していない、平均的なプログラマーがその辺をきちんと学習する機会がさほどない（だからこいう記事の存在理由がある（笑））、というのが理由で、ようやく最近AppleのSwiftでも見られるように関数型（宣言型）プログラミングが陽の目を見ようとする状況になったということでしょう。

今回は、プログラミングで普段あまり語られることがない、もっとも根本的な問題について書きます。
アルゴリズムを脱する為、いわゆる「モダン」な関数型（宣言型）プログラミングを考える上で、必須で根本的な問題を見極める作業になると思います。

##完璧なプログラミング

「１から１０までの数を全部足す」という問題をもう一度考えてみます。

これは言うまでもなく数学の問題で、しかもとても簡潔な問題ですが、数学的厳密性を保ったまま、つまりバグがないようにプログラムするベストな方法は、この「簡潔な問題をそのまま簡潔にコードに書くこと」でした。

そしてその思想が「宣言型プログラミング」のパラダイムです。

①　「１から１０までの数」を用意する。

これは「原始的」な「命令型プログラミング」ではなんだか大変なことのように思えるが、「宣言型プログラミング」では言語や外部ライブラリに実装され抽象化されており、そのための命令、手続きは完全に隠蔽されている。

②　用意したデータの各要素を「すべて足す」という操作をする。

これも同様に宣言型プログラミングでは抽象化されて実装されている。

##分断された２つの世界

数学世界と物理世界です。

###数学世界
「１から１０までの数を全部足す」という数学の問題は数学の世界に属します。
π（パイ）という数字は数学の世界に属します。

そしてプログラムというのも数学的構造の定義に過ぎず、プログラム（コード）は数学の世界に属します。

###物理世界
プログラム（コード）が数学的実体である一方で、プログラムの計算を実行するコンピュータというハードウェアは物理世界に属す物理的実体です。
コンピュータというマシンのリソースは有限で、CPUの速度、メモリ、ドライブの容量、インターネットの通信速度などなど、あらゆる要素がシビアな物理的制約の下にあります。
「速度」というのは、時間要素ですが、物理世界には「時間」という物理要素があります。
数学世界にはもちろん時間要素はありません。抽象概念としてただそこに存在しているだけです。

無限数列であるπ（パイ）という数学的実体を物理世界のデータとして延々と計算することは可能ですが、有限リソースと有限時間しかない（物理世界で無限に計算するのは不可能だし、無限に計算したとしても、計算時間が無限なので最終的な答えではありえない）ので、原理的限界があります。

##プログラムで計算する（評価する：evaluation）とはどういうことか？

プログラムで計算する、というのは、数学世界の実体を物理世界のコンピュータのメモリに読み込み、CPUで処理して、メモリに書き出す作業です。

何の制約もない数学世界の実体をプログラミングを通じて制約まみれの有限の物理世界に展開する行為と言い換えても良いでしょう。

「１から１０までの数を全部足す」という数学の問題の回答は、数学世界において

####=　55

つまり数学的に等価であると、人間が計算する前から最初から答えが決定されている真理であるわけですが、これを我々の物理世界においてその数学世界の真理を確認したいが為に、プログラミングを通じたコンピューティング（計算）で、`55`という結果を有限時間でメモリに書き出し画面に表示させているわけです。

####数学世界　--コンピューティング（計算）--> 　物理世界


##物理世界を数学世界に転写（マッピング）

この記事を読んで、

「なんだか数学の話ばっかりしている」

「仕事に使う実用的プログラム、システム設計は数学の話じゃないんだよ」

「ゲームのプログラミングとかにも使えるの？」

「理論だけで机上の空論だろう、参考にならない、使えない」

と思っている人はきっと多いでしょう。

実際のところ、この当たり前に思える思考こそが、これまで関数型（宣言型）プログラミングの普及を阻害してきた最大の原因です。

そして逆に言うと、この問題さえ解決できれば、我々が追い求めてやまないバグのないメンテナンス性の高い完璧なプログラミングが実用ベースで可能となります。

机上の空論のように思えたのは、これまで

####数学世界　--コンピューティング（計算）--> 　物理世界

の話しかしておらず、逆方向の、

####数学世界　<-- 　物理世界

については一切触れてこなかったからです。

矢印を逆方向にして、今から

####物理世界　--> 　数学世界

の話をします。

実用的なプログラミングでは、物理世界を数学世界にマッピングする作業が肝で、これをモデル化と言います。


####物理世界　--コーディング（モデル化）-->　数学世界

です。

まとめると、

####物理世界　--コーディング（モデル化）-->　数学世界　--コンピューティング（計算）--> 　物理世界

ということになります。

（実用的）プログラミングとは、いかにこの流れを完璧に実現するか？その作業にほかなりません。



##物理世界　--コーディング（モデル化）-->　数学世界を実現する上で障害となる「時間」要素

障害となるものは、この物理世界の「時間」です。

「１から１０までの数を全部足す」という問題では、

①　「１から１０までの数」を用意する。

②　用意したデータの各要素を「すべて足す」という操作をする。

数学的問題を数学的厳密性を保ったまま完結なコーディングを実現する！ということが理想的で実現可能なのはよくわかったけども、たとえば「スマートフォンのゲーム」や「ユーザーのデータベース構築」や「FXトレードのプログラミング」では、

①　「１から１０までの数」を用意する。

②　用意したデータの各要素を「すべて足す」という操作をする。

なんて芸当は絶対無理だ！　故に宣言型パラダイムが喧伝する完璧なプログラミングの理想世界とは机上の空論であり使えない、故に宣言型は放棄するしかなく、命令形パラダイムに固執するしか術がない、と思うのが普通です。

なるほど、ではいったい何故「スマートフォンのゲーム」のプログラミングにおいて

①　「１から１０までの数」を用意する。

が不可能だと思ったのでしょうか？

「こたえは単純でユーザーからの入力を最初に、事前に、全部用意することなどできるはずがないだろう」

「タイムリミットなどの時間要素については一体どう数学的操作するつもりなんだ？」

やはりこの物理世界の「時間要素」が完璧なプログラミングへの最大の障害となるようですね。

##どうやって物理世界を数学世界に転写するのか？

よく考えてみると、そもそも論として、物理学では物理世界の「時間」というのは数学的存在でしかありません。

アインシュタインの相対性理論以降は空間と時間が渾然一体となっている「時空」という数学的存在が明らかになりました。

「時空」の観点から俯瞰してみると、この物理世界は（人間の能が認知する範囲では）３次元＋時間の４次元の数学的実体です。

もうちょっと身近な例で言えば、映画やドラマを鑑賞するとします。
最初から見ていくと、登場人物の動き、シナリオは事前には「予測不能」であるわけですが、実際のところ、そのすべては「DVDに記録されているデジタルデータ」として「最初から、事前にすべてデータとして用意されている」のです。

この物理世界も物理学の世界観からみると、「時空というDVDにあらかじめ最初から全部記録されているデータ」に過ぎません。

じゃあ「時間が流れる」っていうのは一体何なのか？この辺はプログラムの話とはそれる科学哲学的トピックでしょうが、人間の意識の問題であり「脳の錯覚」です。

DVDのデータとは静的な記録であり変化しません。しかしプレイヤーで再生してみると、あたかもそこに世界が広がり時間の流れがあるように見えます。登場人物にも意識があるように見える。しかしDVDプレイヤーの外から見ると、それは実は静的なデータを順番に時系列でなぞっていく作業でしかありません。

入出力、UIのイベントなども、時間とともに非同期に発生するわけですが、時空を俯瞰してみると、イベントのストリームデータとして扱う事が可能です。

実はこれは決して新しいアイデアではなく、UNIXの世界ではとても賢い人が[標準ストリーム](http://ja.wikipedia.org/wiki/%E6%A8%99%E6%BA%96%E3%82%B9%E3%83%88%E3%83%AA%E3%83%BC%E3%83%A0)の形で入出力を統一的なデータとして操作できるように実装していました。

そしてさらに、前回記事でも触れたとおり、標準ストリームはUNIXパイプで操作、操作とチェーン処理することが出来ます。

ならば

「１から１０までの数」を用意する。

であっても

「ユーザーからの入力を最初に、事前に、全部用意すること」

であっても、なんら本質的な違いはなく、両者同等に数学的世界にマッピングして処理が可能なはずです。

そして実際にこの思想をプログラミング実装する手法が、

データバインディング
>データバインディング（データバインド、あるいはData Bindingの訳からデータ結合とも呼ばれる。）とは、XMLなどのデータソースとアプリケーションやウェブページ（ウェブアプリケーション）のユーザインタフェースを静的または動的に結合する技術である。分離されたデータソースとユーザインタフェースの間を橋渡しする役割を果たし、データが変更されるとそれに応じてユーザインタフェースが変更される一方向なデータバインディングと、併せてユーザインタフェースの変更または操作に応じてデータが変更される双方向のデータバインディングがある。

であり、
リアクティブプログラミング
http://en.wikipedia.org/wiki/Reactive_programming

http://gihyo.jp/dev/serial/01/meteor/0010
>リアクティブ・プログラミングとは，端的に言うと，あるデータに対して行った変更が自動的に伝播し，その他の部分に影響をおよぼすようなプログラミング・パラダイムのことです。たとえば表計算ソフトの一般的な機能として，セルの値に応じて，そのセルを参照している部分の値も自動的に変更されるというものがありますが，これはリアクティブ・プログラミングの典型的な例です。また，MVCフレームワークの中には，モデルの値を変更すると自動的にビューが更新されるという機能を持つ（バインディングと呼ばれます）ものもありますが，これもリアクティブ・プログラミングの例と言って良いでしょう。


で、
特に、関数型（宣言型）パラダイムとリアクティブプログラミングを統合したものを
関数型（ファンクショナル）リアクティブプログラミング（FRP）
http://en.wikipedia.org/wiki/Functional_reactive_programming

と呼びます。


注目を集めるリアクティブプログラミング　　
http://www.infoq.com/jp/news/2013/09/reactive-programming-emerging

「１から１０までの数字」という数列データは、 **数直線上** に存在しているデータですが、FRPでは、イベントというのは **時間軸上** に存在しているデータです。

今注目を集めるFRPとは、物理世界を数学世界にマッピングする、時空を俯瞰したプログラミングパラダイムである、と言っても過言ではないでしょう。

##FRPのJavaScriptでの実装「Bacon.js」

https://github.com/baconjs/


Bacon.jsを用いて、HTMLのDOMのBOXをドラッグするデモです。
実際に操作できます。

http://jsfiddle.net/LLB63/


```
var xyFromEvent = function (v) {
    return {
        x: v.clientX,
        y: v.clientY
    }
}

var getDelta = function (t) {
    var a = t[1];
    var b = t[0];
    return {
        x: a.x - b.x,
        y: a.y - b.y
    };
}

var add = function (p1, p2) {
    return {
        x: p1.x + p2.x,
        y: p1.y + p2.y
    };
}

$().ready(function () {
    var block = $("#clickable-block");
    var html = $("html");

    var startDrag = block.asEventStream('mousedown')
    var endDrag = block.asEventStream('mouseup')

    var draggingDeltas = startDrag.flatMap(function () {
        return html.asEventStream('mousemove')
            .map(xyFromEvent)
            .slidingWindow(2, 2)
            .map(getDelta)
            .takeUntil(endDrag)
    })

    var blockPosition = draggingDeltas.scan({
        x: 0,
        y: 0
    }, add);

    blockPosition.onValue(function (pos) {
        block.css({
            top: pos.y + "px",
            left: pos.x + "px"
        });
    });
});
```

　　
とても簡潔なコードです。
IFだとかForループなどは存在しません。
すべて宣言、宣言、宣言でコードが成立しており、どこにも「アルゴリズム」らしきものが存在しないことがわかるでしょうか？

FRP、宣言型パラダイムのキモとなるコードは

```
 var startDrag = block.asEventStream('mousedown')
 var endDrag = block.asEventStream('mouseup')

 var draggingDeltas = startDrag.flatMap(function () {
        return html.asEventStream('mousemove')
            .map(xyFromEvent)
            .slidingWindow(2, 2)
            .map(getDelta)
            .takeUntil(endDrag)
    })
```
ここで、
`mousedown`　のイベントを`startDrag`というイベントストリーム、

`mouseup`　のイベントを`endDrag`というイベントストリーム、

`mousemove` のイベントストリームとデータ合成し、

`draggingDeltas` というマウスポインタの移動ベクトルを算出しています。

同時に、

```
blockPosition.onValue(function (pos) {
        block.css({
            top: pos.y + "px",
            left: pos.x + "px"
        });
    });
```
で、データに変更があれば、DOM要素のCSSに反映させ、オブジェクトを移動させる。

時間要素がある物理世界の入出力（IO）をデータとして、そしてそのデータの加工を宣言（モデル化）し、結果をまた物理世界に反映させる。
これが、関数型リアクティブプログラミングという宣言型プログラミングバラダイムです。

Implementing Snake in Bacon.js
http://philipnilsson.github.io/badness/

こちらのサイトでは「スネークゲーム」をBacon.jsを利用してFRP,宣言型パラダイムでプログラムしています。

ユーザの入力が時系列を俯瞰したデータとして宣言的に処理されている様子がページに埋め込まれたデモと共に（Webサイト上でライブデモがすぐ見れるのがJSの強み）わかりやすく書かれています。

###次回は宣言型パラダイムと切り離せない遅延評価について解説します。


#### KenOKABE tech blog
####[←ブログコンテンツ](http://kenokabe.github.io/contents/entries/entry0/entry.html)
