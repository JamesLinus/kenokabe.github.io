#### KenOKABE tech blog
####[←ブログコンテンツ](http://kenokabe.github.io/contents/entries/entry0/entry.html)

#記事シリーズ
### [Swiftで脱アルゴリズム！iOS開発を関数型（宣言型）プログラミングへパラダイムシフトしてみる【脱アルゴリズム宣言①】](http://qiita.com/kenokabe/items/41189c45001321c9e283)
###  [関数リアクティブプログラミング（FRP）で分断された2つの世界を繋ぐ【脱アルゴリズム宣言②】](http://qiita.com/kenokabe/items/a8477694a499ca869cde)
### [関数型（宣言型）プログラミングで無限をコーディングする「遅延評価」のわかりやすい解説【脱アルゴリズム宣言③】](http://qiita.com/kenokabe/items/821ce4020644372b648c)

###[時空プログラミング 遅延評価とFRPで無限の時空を静的にコーディングする挑戦【時空プログラミング①】]()

#時空プログラミング 遅延評価とFRPで無限の時空を静的にコーディングする挑戦【時空プログラミング①】

さて、今回からは、「時空プログラミング」と冠して、大きな花火をぶち上げながら開始してみます。

**時空をプログラミングする** っていうと「こりゃまた大風呂敷を広げたな」と思う人がきっと多いでしょう。

しかしかしながら、実際のところ、プログラミングパラダイムの変遷とは 究極的に**時空をプログラミングする** という一大哲学的目標に向けて進化し続けていると言ってもけして過言ではありません。


[コンピュータ・サイエンス](http://ja.wikipedia.org/wiki/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%A6)
によれば、
>計算機科学という名前にも関わらず、計算機科学の研究対象は物理的な電子計算機そのものではない。例えば著名な計算機科学者エドガー・ダイクストラは「天文学が望遠鏡に関する学問でないのと同様に、計算機科学はコンピュータに関する学問ではない」という言葉を残している。コンピュータの設計と開発は計算機科学の領域外の話である。例えばハードウェアは計算機工学の領域であるし、商用コンピュータシステムとその利用は情報技術とか情報システムと呼ばれる。ただし、コンピュータのハードウェアはその計算手法と密接な関係にあり、応用技術のなかにも計算機科学の対象となる部分がある。また、計算機科学と他の周辺学問分野との間では新たな学問がいくつも生まれている。計算機科学と関係の深い学問分野として、哲学、経済学、数学、物理学、言語学などを挙げることができる。

>一部の人々は計算機科学は数学と最も関連が深いとみなしている[7]。初期の計算機科学はクルト・ゲーデルやアラン・チューリングなどの数学での業績に強い影響を受けていたし、数理論理学、圏論、領域理論、代数学といった領域は計算機科学と数学の間でアイデアをやり取りする領域となっている。

>計算機科学とソフトウェア工学の関係は論争の的である。「ソフトウェア工学」という言葉が表すものが何か、計算機科学の範囲をどう定めるかは長年の議論の対象となっている。一部の人々はソフトウェア工学が計算機科学の一部であると信じている。他の人々は、計算機科学が計算全般を扱う学問であるのに対して、ソフトウェア工学は実用的な目的でコンピュータ処理を設計するものであり、異なる学問分野であると考えている。この見方の例としてデイビッド・パーナスがいる[10]。他の人々はソフトウェアは全く工学的に扱うことはできていないと考えている。

- 計算機科学の研究対象は物理的な電子計算機そのものではない

- 計算機科学の理論的基盤はもちろん数学である

- 「ソフトウェア工学」とは計算機科学を応用する工学（エンジニアリング）である

だいたいこんな感じで、明確なコンセンサスには至っていない、というのが読み取れます。

コンピュータサイエンス、ソフトウェア工学とは学際分野であり、明確な概念化が難しいのでしょう。

本稿も、数学、科学、工学と学問領域をクロスオーバーします。

**時空をプログラミングする**というフレーズは、端的に、数学、科学、工学をまたぐ学際的作業を試みているから、こういう表現になるでしょう。

- 計算機科学の研究対象は物理的な電子計算機そのものではない

- 計算機科学の理論的基盤はもちろん数学である

数学の理論的基盤を物理的な計算機で展開する、この工学的手法がプログラミングです。

この点を【脱アルゴリズム宣言】シリーズでの説明を振り返ると、

####数学世界　--コンピューティング（計算）--> 　物理世界

数学世界を物理世界へ展開する工学手法として、これまでのところ、物理マシンとしてのコンピュータによる物理的な処理プロセス、ステップByステップの命令型（手続き型）パラダイムの束縛からなかなか抜け出せないでいました。

プログラミング言語は、機械語、アセンブリ、フォートラン、C言語、C++、Javaなどなど徐々に物理的な処理プロセスから「高級言語」へと（数学的に）抽象化されいったのですが、実務的なプログラミング作業では、これまで命令型（手続き型）パラダイムが主流となっていました。

その大きな理由は、実務的プログラミングの世界では、ほとんどすべてのケースにおいて、非同期な入出力を扱うことになり、非同期な入出力（IO）は数学的に抽象化することが極めて困難だからです。

つまり、

####物理世界　--コーディング（モデル化）-->　数学世界

の部分で完全に壁にぶち当たっており、

####物理世界　--コーディング（モデル化）-->　数学世界　--コンピューティング（計算）--> 　物理世界

という全体像のソフトウェア工学は大きな問題を抱えてきました。

##数学のように見えて数学ではない破綻した数学モデル

私が初めてプログラミングしたのは、小学校4年の頃で、父親が仕事に使うことを見越して家に買って帰ってきたHITACHIのBASICマスターというパソコンでした。

今も昔も変わらないな、と思うのですが、子供はゲームに夢中です。どうもこのパソコンっていうのは自分でプログラムを打ち込むとゲームができるらしい、ということがわかりました。近所の本屋に行くと[マイコンBASICマガジン](http://ja.wikipedia.org/wiki/%E3%83%9E%E3%82%A4%E3%82%B3%E3%83%B3BASIC%E3%83%9E%E3%82%AC%E3%82%B8%E3%83%B3)、知る人ぞ知る、通称「ベーマガ」が積み置かれていました。興奮して早速購入し、BASICの「プログラムリスト」（ソースコード）を打ち込みました。

BASICである変数を1つ増やすのは、

```
X = X + 1
```

です、ゲーム画面上のキャラクターの座標をひとつ移動させるときに頻繁に使われる極めてありふれたコードです。

この頃はまだ、小学4年だったので、算数の授業では「方程式」と言うのを習っておらず、何の疑問も抱かなかったのですが、中学に進学し、数学の授業で「方程式」の概念を習うと、

```
X = X + 1
```

というのは数学の方程式としては成り立たない、ということがわかりました。

「なるほど、どうやら、数学の方程式と、プログラミングとは違うようだ」

と気づきました。

数学の方程式の授業で代入というのを習いましたが、

数学の方程式の代入が、

- 式や関数に含まれる文字や変数を、数や他の文字や式で置き換えること

であることに対して、

プログラミングの代入は

- 変数の値を設定（ないし変更）すること（assignment）

という命令であり、

同じ数学的な言葉「代入」の意味がぜんぜん違う！ということに愕然としました。

愕然とした、というよりは、「なんかこれは後々ややこしい混乱を招くに違いない」「面倒を抱えた」と本能的な不快感を覚えました。

「代入」にはふたつの異なる意味がある。

http://ja.wikipedia.org/wiki/%E4%BB%A3%E5%85%A5

結果として、これが数学という本質的に宣言型パラダイムを認識し、自分がそれと異なる命令型パラダイムにいると、ぼんやりとではありますが自覚した瞬間だったと言えるでしょう。

しかし、その頃はコンピュータの動作原理などはおおよそ理解していたので、これは原理的に回避できない問題であり、コンピュータでプログラミングするには、宣言型である数学ではない、命令型パラダイムでステップByステップの変数への代入操作を繰り返していくしか無い、と思っていました。それがプログラミングなのだと。

命令型プログラミングにおける代入は　**破壊的代入**と呼ばれたりします。

##数学世界の破綻と数学世界への決別

BASICがポピュラーだった頃、Cが登場してもてはやされていた頃のプログラマーは一部のコンピュータ科学の研究者をのぞいて、ほぼすべてこの踏み絵を踏まされていたのです。

当時、命令型プログラミングとは、実務やゲームのプログラミングにおいて唯一無比の、他に選択肢のないデフォルトのパラダイムでした。

しかし、ちょうどその頃、我々一般的なプログラマーが関知もしていないところで、研究者たちは、関数型プログラミング言語の研究を進めていました。

関数型言語でもっとも古株はLISPで、LISPは、全てのプログラミング言語の中でも2番目に古い高級言語であるようです。

LISPはその他Schemeに派生し、現在に広く使用されているようですが、実務で使用されているケースはあまり聞いたことはありません。理由はこの記事シリーズで書いているとおりです。

ちなみに、私はLISPとSchemeを結構触ってみましたが、好きになれませんでした。
触れば触るほど嫌いになってきました。













、このデータ構造を採用していることにより、

####数学世界　--コンピューティング（計算）--> 　物理世界


#### KenOKABE tech blog
####[←ブログコンテンツ](http://kenokabe.github.io/contents/entries/entry0/entry.html)
